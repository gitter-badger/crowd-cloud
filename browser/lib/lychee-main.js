
/*
 * lycheeJS 0.8
 * 
 * {"platform":["html"]}
 * 
 * lychee.Input
 * lychee.Renderer
 * lychee.Storage
 * lychee.Viewport
 * lychee.event.Emitter
 * lychee.game.Entity
 * lychee.game.Jukebox
 * lychee.game.Layer
 * lychee.game.Logic
 * lychee.game.Loop
 * lychee.game.Main
 * lychee.game.Physic
 * lychee.game.State
 * lychee.net.Client
 * lychee.net.Service
 * lychee.ui.Entity
 * lychee.ui.Layer
 */


(function(lychee, global) {

	var environment = lychee.deserialize({
	"constructor": "lychee.Environment",
	"arguments": [
		{
			"id": "lychee/html/main",
			"build": "lychee.game.Main",
			"debug": false,
			"sandbox": false,
			"type": "build",
			"tags": {
				"platform": [
					"html"
				]
			}
		}
	],
	"blob": {
		"definitions": {
			"lychee.game.Main": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Main"
				],
				"blob": {
					"requires": [
						"lychee.Input",
						"lychee.Renderer",
						"lychee.Storage",
						"lychee.Viewport",
						"lychee.game.Jukebox",
						"lychee.game.Loop",
						"lychee.game.State",
						"lychee.net.Client"
					],
					"includes": [
						"lychee.event.Emitter"
					],
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _load_client = function(url) {\n\n\t\turl = typeof url === 'string' ? url : '/api/Server?identifier=boilerplate';\n\n\n\t\tvar asset = lychee.Environment.createAsset(url, 'json');\n\t\tif (asset !== null) {\n\n\t\t\tvar that = this;\n\n\t\t\tasset.onload = function(result) {\n\n\t\t\t\tif (result === true) {\n\t\t\t\t\tthat.settings.client = lychee.extend({}, this.buffer);\n\t\t\t\t}\n\n\t\t\t\t_initialize.call(that);\n\n\t\t\t};\n\n\t\t\tasset.load();\n\n\t\t}\n\n\t};\n\n\tvar _load_server = function(url) {\n\n\t\t// TODO: Server or Router initialization\n\n\t};\n\n\tvar _initialize = function() {\n\n\t\tthis.trigger('load', []);\n\n\n\t\tvar settings = this.settings;\n\n\t\tif (settings.client !== null) {\n\n\t\t\tthis.client = new lychee.net.Client(settings.client);\n\n\n\t\t\tvar port = settings.client.port || null;\n\t\t\tvar host = settings.client.host || null;\n\t\t\tif (port !== null && host !== null) {\n\t\t\t\tthis.client.listen(port, host);\n\t\t\t}\n\n\t\t}\n\n\t\tif (settings.input !== null) {\n\t\t\tthis.input = new lychee.Input(settings.input);\n\t\t}\n\n\t\tif (settings.jukebox !== null) {\n\t\t\tthis.jukebox = new lychee.game.Jukebox(settings.jukebox);\n\t\t}\n\n\t\tif (settings.loop !== null) {\n\t\t\tthis.loop = new lychee.game.Loop(settings.loop);\n\t\t\tthis.loop.bind('render', this.render, this);\n\t\t\tthis.loop.bind('update', this.update, this);\n\t\t}\n\n\t\tif (settings.renderer !== null) {\n\t\t\tthis.renderer = new lychee.Renderer(settings.renderer);\n\t\t}\n\n\t\tif (settings.viewport !== null) {\n\n\t\t\tthis.viewport = new lychee.Viewport();\n\t\t\tthis.viewport.bind('reshape', this.reshape, this);\n\t\t\tthis.viewport.bind('hide',    this.hide,    this);\n\t\t\tthis.viewport.bind('show',    this.show,    this);\n\n\t\t\tthis.viewport.setFullscreen(settings.viewport.fullscreen);\n\n\t\t}\n\n\n\t\tthis.trigger('init', []);\n\n\t};\n\n\n\n\t/*\n\t * DEFAULT SETTINGS\n\t * and SERIALIZATION CACHE\n\t */\n\n\tvar _defaults = {\n\n\t\tinput: {\n\t\t\tdelay:       0,\n\t\t\tkey:         false,\n\t\t\tkeymodifier: false,\n\t\t\ttouch:       true,\n\t\t\tswipe:       false\n\t\t},\n\n\t\tjukebox: {\n\t\t\tchannels: 8,\n\t\t\tmusic:    true,\n\t\t\tsound:    true\n\t\t},\n\n\t\tloop: {\n\t\t\trender: 60,\n\t\t\tupdate: 60\n\t\t},\n\n\t\trenderer: {\n\t\t\twidth:      null,\n\t\t\theight:     null,\n\t\t\tid:         'game',\n\t\t\tbackground: '#222222'\n\t\t},\n\n\t\tstorage: {\n\t\t\tid:    'game',\n\t\t\tmodel: {},\n\t\t\ttype:  lychee.Storage.TYPE.persistent\n\t\t},\n\n\t\tviewport: {\n\t\t\tfullscreen: false\n\t\t},\n\n\t\tclient: null,\n\t\tserver: null\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(settings) {\n\n\t\tthis.settings = lychee.extendunlink({}, _defaults, settings);\n\t\tthis.defaults = lychee.extendunlink({}, this.settings);\n\n\t\tthis.client   = null;\n\t\tthis.input    = null;\n\t\tthis.jukebox  = null;\n\t\tthis.loop     = null;\n\t\tthis.renderer = null;\n\t\tthis.storage  = null;\n\t\tthis.viewport = null;\n\n\t\tthis.__states = {};\n\t\tthis.__state  = null;\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tfor (var id in blob.states) {\n\n\t\t\t\tvar stateblob = blob.states[id];\n\n\t\t\t\tfor (var a = 0, al = stateblob.arguments.length; a < al; a++) {\n\t\t\t\t\tif (stateblob.arguments[a] === '#MAIN') {\n\t\t\t\t\t\tstateblob.arguments[a] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setState(id, lychee.deserialize(stateblob));\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = lychee.extendunlink({}, this.settings);\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.input !== null)    blob.input    = lychee.serialize(this.input);\n\t\t\tif (this.viewport !== null) blob.viewport = lychee.serialize(this.viewport);\n\n\n\t\t\tif (Object.keys(this.__states).length > 0) {\n\n\t\t\t\tblob.states = {};\n\n\t\t\t\tfor (var id in this.__states) {\n\t\t\t\t\tblob.states[id] = lychee.serialize(this.__states[id]);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Main',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * LOOP INTEGRATION\n\t\t */\n\n\t\trender: function(clock, delta) {\n\n\t\t\tif (this.__state !== null) {\n\t\t\t\tthis.__state.render(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tif (this.__state !== null) {\n\t\t\t\tthis.__state.update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * VIEWPORT INTEGRATION\n\t\t */\n\n\t\tshow: function() {\n\n\t\t\tvar loop = this.loop;\n\t\t\tif (loop !== null) {\n\t\t\t\tloop.resume();\n\t\t\t}\n\n\t\t\tvar state = this.getState();\n\t\t\tif (state !== null) {\n\t\t\t\tstate.show();\n\t\t\t}\n\n\t\t},\n\n\t\thide: function() {\n\n\t\t\tvar loop = this.loop;\n\t\t\tif (loop !== null) {\n\t\t\t\tloop.pause();\n\t\t\t}\n\n\t\t\tvar state = this.getState();\n\t\t\tif (state !== null) {\n\t\t\t\tstate.hide();\n\t\t\t}\n\n\t\t},\n\n\t\treshape: function(orientation, rotation) {\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tvar settings = this.settings;\n\t\t\t\tif (settings.renderer !== null) {\n\t\t\t\t\trenderer.setWidth(settings.renderer.width);\n\t\t\t\t\trenderer.setHeight(settings.renderer.height);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfor (var id in this.__states) {\n\n\t\t\t\tvar state = this.__states[id];\n\n\t\t\t\tstate.reshape(\n\t\t\t\t\torientation,\n\t\t\t\t\trotation\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\tinit: function() {\n\n\t\t\tvar async      = false;\n\t\t\tvar clientdata = this.settings.client;\n\t\t\tvar serverdata = this.settings.server;\n\n\t\t\tif (this.client === null && typeof clientdata === 'string') {\n\t\t\t\t_load_client.call(this, clientdata);\n\t\t\t\tasync = true;\n\t\t\t}\n\n\t\t\tif (this.server === null && typeof serverdata === 'string') {\n\t\t\t\t_load_server.call(this, serverdata);\n\t\t\t\tasync = true;\n\t\t\t}\n\n\n\t\t\tif (async === false) {\n\t\t\t\t_initialize.call(this);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * STATE MANAGEMENT\n\t\t */\n\n\t\tsetState: function(id, state) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (lychee.interfaceof(lychee.game.State, state)) {\n\n\t\t\t\tif (id !== null) {\n\n\t\t\t\t\tthis.__states[id] = state;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\t\t\t\treturn this.__states[id] || null;\n\t\t\t}\n\n\n\t\t\treturn this.__state || null;\n\n\t\t},\n\n\t\tisState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\t\t\t\treturn this.__state === this.__states[id];\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__states[id] !== undefined) {\n\n\t\t\t\tdelete this.__states[id];\n\n\t\t\t\tif (this.__state === this.__states[id]) {\n\t\t\t\t\tthis.changeState(null);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tchangeState: function(id, data) {\n\n\t\t\tid   = typeof id === 'string' ? id   : null;\n\t\t\tdata = data instanceof Object ? data : null;\n\n\n\t\t\tvar oldstate = this.__state;\n\t\t\tvar newstate = this.__states[id] || null;\n\n\t\t\tif (newstate !== null) {\n\n\t\t\t\tif (oldstate !== null) {\n\t\t\t\t\toldstate.leave();\n\t\t\t\t}\n\n\t\t\t\tif (newstate !== null) {\n\t\t\t\t\tnewstate.enter(data);\n\t\t\t\t}\n\n\t\t\t\tthis.__state = newstate;\n\n\t\t\t} else {\n\n\t\t\t\tif (oldstate !== null) {\n\t\t\t\t\toldstate.leave();\n\t\t\t\t}\n\n\t\t\t\tthis.__state = null;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.event.Emitter": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.event.Emitter"
				],
				"blob": {
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _unbind = function(type, callback, scope) {\n\n\t\tif (this.___events[type] !== undefined) {\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var e = 0, el = this.___events[type].length; e < el; e++) {\n\n\t\t\t\tvar entry = this.___events[type][e];\n\n\t\t\t\tif ((callback === null || entry.callback === callback) && (scope === null || entry.scope === scope)) {\n\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\tthis.___events[type].splice(e, 1);\n\t\t\t\t\tel--;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function() {\n\n\t\tthis.___events = {};\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tbind: function(type, callback, scope, once) {\n\n\t\t\ttype     = typeof type === 'string'     ? type     : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : this;\n\t\t\tonce     = once === true;\n\n\n\t\t\tif (type === null || callback === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tvar passAction = false;\n\t\t\tvar passSelf   = false;\n\n\t\t\tif (type.charAt(0) === '@') {\n\t\t\t\ttype = type.substr(1, type.length - 1);\n\t\t\t\tpassAction = true;\n\t\t\t} else if (type.charAt(0) === '#') {\n\t\t\t\ttype = type.substr(1, type.length - 1);\n\t\t\t\tpassSelf = true;\n\t\t\t}\n\n\n\t\t\tif (this.___events[type] === undefined) {\n\t\t\t\tthis.___events[type] = [];\n\t\t\t}\n\n\n\t\t\tthis.___events[type].push({\n\t\t\t\tpassAction: passAction,\n\t\t\t\tpassSelf:   passSelf,\n\t\t\t\tcallback:   callback,\n\t\t\t\tscope:      scope,\n\t\t\t\tonce:       once\n\t\t\t});\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\ttrigger: function(type, data) {\n\n\t\t\ttype = typeof type === 'string' ? type : null;\n\t\t\tdata = data instanceof Array    ? data : null;\n\n\n\t\t\tif (this.___events[type] !== undefined) {\n\n\t\t\t\tvar value = undefined;\n\n\t\t\t\tfor (var e = 0; e < this.___events[type].length; e++) {\n\n\t\t\t\t\tvar args  = [];\n\t\t\t\t\tvar entry = this.___events[type][e];\n\n\t\t\t\t\tif (entry.passAction === true) {\n\n\t\t\t\t\t\targs.push(type);\n\t\t\t\t\t\targs.push(this);\n\n\t\t\t\t\t} else if (entry.passSelf === true) {\n\n\t\t\t\t\t\targs.push(this);\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (data !== null) {\n\t\t\t\t\t\targs.push.apply(args, data);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar result = entry.callback.apply(entry.scope, args);\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (entry.once === true) {\n\n\t\t\t\t\t\tif (this.unbind(type, entry.callback, entry.scope) === true) {\n\t\t\t\t\t\t\te--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tunbind: function(type, callback, scope) {\n\n\t\t\ttype     = typeof type === 'string'     ? type     : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : null;\n\n\n\t\t\tvar found = false;\n\n\t\t\tif (type !== null) {\n\n\t\t\t\tfound = _unbind.call(this, type, callback, scope);\n\n\t\t\t} else {\n\n\t\t\t\tfor (type in this.___events) {\n\n\t\t\t\t\tvar result = _unbind.call(this, type, callback, scope);\n\t\t\t\t\tif (result === true) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.Input": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.Input"
				],
				"blob": {
					"tags": {
						"platform": "html"
					},
					"includes": [
						"lychee.event.Emitter"
					],
					"supports": "function (lychee, global) {\n\n\tif (typeof global.addEventListener === 'function') {\n\t\treturn true;\n\t}\n\n\n\treturn false;\n\n}",
					"exports": "function (lychee, global) {\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _instances = [];\n\n\tvar _mouseactive = false;\n\tvar _listeners = {\n\n\t\tkeydown: function(event) {\n\n\t\t\tvar handled = false;\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\thandled = _process_key.call(_instances[i], event.keyCode, event.ctrlKey, event.altKey, event.shiftKey) || handled;\n\t\t\t}\n\n\n\t\t\tif (handled === true) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\n\t\t},\n\n\t\ttouchstart: function(event) {\n\n\t\t\tvar handled = false;\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\n\t\t\t\tif (event.touches && event.touches.length) {\n\n\t\t\t\t\tfor (var t = 0, tl = event.touches.length; t < tl; t++) {\n\t\t\t\t\t\thandled = _process_touch.call(_instances[i], t, event.touches[t].pageX, event.touches[t].pageY) || handled;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\thandled = _process_touch.call(_instances[i], 0, event.pageX, event.pageY) || handled;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Prevent scrolling and swiping behaviour\n\t\t\tif (handled === true) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\n\t\t},\n\n\t\ttouchmove: function(event) {\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\n\t\t\t\tif (event.touches && event.touches.length) {\n\n\t\t\t\t\tfor (var t = 0, tl = event.touches.length; t < tl; t++) {\n\t\t\t\t\t\t_process_swipe.call(_instances[i], t, 'move', event.touches[t].pageX, event.touches[t].pageY);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t_process_swipe.call(_instances[i], 0, 'move', event.pageX, event.pageY);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\ttouchend: function(event) {\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\n\t\t\t\tif (event.touches && event.touches.length) {\n\n\t\t\t\t\tfor (var t = 0, tl = event.touches.length; t < tl; t++) {\n\t\t\t\t\t\t_process_swipe.call(_instances[i], t, 'end', event.touches[t].pageX, event.touches[t].pageY);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t_process_swipe.call(_instances[i], 0, 'end', event.pageX, event.pageY);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tmousestart: function(event) {\n\n\t\t\t_mouseactive = true;\n\n\n\t\t\tvar handled = false;\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\thandled = _process_touch.call(_instances[i], 0, event.pageX, event.pageY) || handled;\n\t\t\t}\n\n\n\t\t\t// Prevent drag of canvas as image\n\t\t\tif (handled === true) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\n\t\t},\n\n\t\tmousemove: function(event) {\n\n\t\t\tif (_mouseactive === false) return;\n\n\n\t\t\tvar handled = false;\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\thandled = _process_swipe.call(_instances[i], 0, 'move', event.pageX, event.pageY) || handled;\n\t\t\t}\n\n\n\t\t\t// Prevent selection of canvas as content\n\t\t\tif (handled === true) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\n\t\t},\n\n\t\tmouseend: function(event) {\n\n\t\t\tif (_mouseactive === false) return;\n\n\t\t\t_mouseactive = false;\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t_process_swipe.call(_instances[i], 0, 'end', event.pageX, event.pageY);\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\t(function() {\n\n\t\tvar keyboard = 'onkeydown' in global;\n\t\tvar touch    = 'ontouchstart' in global;\n\t\tvar mouse    = 'onmousedown' in global;\n\n\n\t\tif (typeof global.addEventListener === 'function') {\n\n\t\t\tif (keyboard) {\n\t\t\t\tglobal.addEventListener('keydown',    _listeners.keydown,    true);\n\t\t\t}\n\n\t\t\tif (touch) {\n\n\t\t\t\tglobal.addEventListener('touchstart', _listeners.touchstart, true);\n\t\t\t\tglobal.addEventListener('touchmove',  _listeners.touchmove,  true);\n\t\t\t\tglobal.addEventListener('touchend',   _listeners.touchend,   true);\n\n\t\t\t} else if (mouse) {\n\n\t\t\t\tglobal.addEventListener('mousedown',  _listeners.mousestart, true);\n\t\t\t\tglobal.addEventListener('mousemove',  _listeners.mousemove,  true);\n\t\t\t\tglobal.addEventListener('mouseup',    _listeners.mouseend,   true);\n\t\t\t\tglobal.addEventListener('mouseout',   _listeners.mouseend,   true);\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (keyboard) methods.push('Keyboard');\n\t\t\tif (touch)    methods.push('Touch');\n\t\t\tif (mouse)    methods.push('Mouse');\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.Input: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.info('lychee.Input: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\t})();\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _process_key = function(code, ctrl, alt, shift) {\n\n\t\tif (this.key === false) return false;\n\n\n\t\t// 1. Validate key event\n\t\tif (Class.KEYMAP[code] === undefined && Class.SPECIALMAP[code] === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\n\t\tctrl  =  ctrl === true;\n\t\talt   =   alt === true;\n\t\tshift = shift === true;\n\n\n\t\t// 2. Only fire after the enforced delay\n\t\tvar delta = Date.now() - this.__clock.key;\n\t\tif (delta < this.delay) {\n\t\t\treturn true;\n\t\t}\n\n\n\t\t// 3. Check for current key being a modifier\n\t\tif (this.keymodifier === false) {\n\n\t\t\tif (code === 16 && shift === true) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (code === 17 && ctrl === true) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (code === 18 && alt === true) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar key  = null;\n\t\tvar name = null;\n\t\tvar tmp  = null;\n\n\t\t// 3a. Check for special characters (that can be shifted)\n\t\tif (Class.SPECIALMAP[code] !== undefined) {\n\n\t\t\ttmp  = Class.SPECIALMAP[code];\n\t\t\tkey  = shift === true ? tmp[1] : tmp[0];\n\t\t\tname = '';\n\n\t\t\tif (ctrl  === true) name += 'ctrl-';\n\t\t\tif (alt   === true) name += 'alt-';\n\t\t\tif (shift === true) name += 'shift-';\n\n\t\t\tname += tmp[0];\n\n\n\t\t// 3b. Check for normal characters\n\t\t} else if (Class.KEYMAP[code] !== undefined) {\n\n\t\t\tkey  = Class.KEYMAP[code];\n\t\t\tname = '';\n\n\t\t\tif (ctrl  === true && key !== 'ctrl')  name += 'ctrl-';\n\t\t\tif (alt   === true && key !== 'alt')   name += 'alt-';\n\t\t\tif (shift === true && key !== 'shift') name += 'shift-';\n\n\n\t\t\tif (shift === true && key !== 'ctrl' && key !== 'alt' && key !== 'shift') {\n\n\t\t\t\ttmp = String.fromCharCode(code);\n\t\t\t\tkey = tmp !== '' ? tmp : key;\n\n\t\t\t}\n\n\t\t\tname += key.toLowerCase();\n\n\t\t}\n\n\n\t\tvar handled = false;\n\n\t\tif (key !== null) {\n\n\t\t\t// bind('key') and bind('ctrl-a');\n\t\t\t// bind('!')   and bind('shift-1');\n\n\t\t\thandled = this.trigger('key', [ key, name, delta ]) || handled;\n\t\t\thandled = this.trigger(name,  [ delta ])            || handled;\n\n\n\t\t\tif (handled === true) {\n\n\t\t\t\tif (lychee.debug === true) {\n\t\t\t\t\tthis.__history.key.push([ Date.now(), key, name, delta ]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.__clock.key = Date.now();\n\n\n\t\treturn handled;\n\n\t};\n\n\tvar _process_touch = function(id, x, y) {\n\n\t\tif (this.touch === false && this.swipe === true) {\n\n\t\t\tif (this.__swipes[id] === null) {\n\t\t\t\t_process_swipe.call(this, id, 'start', x, y);\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else if (this.touch === false) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\n\t\t// 1. Only fire after the enforced delay\n\t\tvar delta = Date.now() - this.__clock.touch;\n\t\tif (delta < this.delay) {\n\t\t\treturn true;\n\t\t}\n\n\n\t\tvar handled = false;\n\n\t\thandled = this.trigger('touch', [ id, { x: x, y: y }, delta ]) || handled;\n\n\n\t\tif (handled === true) {\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tthis.__history.touch.push([ Date.now(), id, { x: x, y: y }, delta ]);\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.__clock.touch = Date.now();\n\n\n\t\t// 2. Fire Swipe Start, but only for tracked touches\n\t\tif (this.__swipes[id] === null) {\n\t\t\thandled = _process_swipe.call(this, id, 'start', x, y) || handled;\n\t\t}\n\n\n\t\treturn handled;\n\n\t};\n\n\tvar _process_swipe = function(id, state, x, y) {\n\n\t\tif (this.swipe === false) return false;\n\n\n\t\t// 1. Only fire after the enforced delay\n\t\tvar delta = Date.now() - this.__clock.swipe;\n\t\tif (delta < this.delay) {\n\t\t\treturn true;\n\t\t}\n\n\n\t\tvar position = { x: x, y: y };\n\t\tvar swipe    = { x: 0, y: 0 };\n\n\t\tif (this.__swipes[id] !== null) {\n\n\t\t\t// FIX for touchend events\n\t\t\tif (state === 'end' && x === 0 && y === 0) {\n\t\t\t\tposition.x = this.__swipes[id].x;\n\t\t\t\tposition.y = this.__swipes[id].y;\n\t\t\t}\n\n\t\t\tswipe.x = x - this.__swipes[id].x;\n\t\t\tswipe.y = y - this.__swipes[id].y;\n\n\t\t}\n\n\n\t\tvar handled = false;\n\n\n\t\tif (state === 'start') {\n\n\t\t\thandled = this.trigger(\n\t\t\t\t'swipe',\n\t\t\t\t[ id, 'start', position, delta, swipe ]\n\t\t\t) || handled;\n\n\t\t\tthis.__swipes[id] = {\n\t\t\t\tx: x, y: y\n\t\t\t};\n\n\t\t} else if (state === 'move') {\n\n\t\t\thandled = this.trigger(\n\t\t\t\t'swipe',\n\t\t\t\t[ id, 'move', position, delta, swipe ]\n\t\t\t) || handled;\n\n\t\t} else if (state === 'end') {\n\n\t\t\thandled = this.trigger(\n\t\t\t\t'swipe',\n\t\t\t\t[ id, 'end', position, delta, swipe ]\n\t\t\t) || handled;\n\n\t\t\tthis.__swipes[id] = null;\n\n\t\t}\n\n\n\t\tif (handled === true) {\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tthis.__history.swipe.push([ Date.now(), id, state, { x: position.x, y: position.y }, delta, { x: swipe.x, y: swipe.y }]);\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.__clock.swipe = Date.now();\n\n\n\t\treturn handled;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.delay       = 0;\n\t\tthis.key         = false;\n\t\tthis.keymodifier = false;\n\t\tthis.touch       = false;\n\t\tthis.swipe       = false;\n\n\t\tthis.__clock   = {\n\t\t\tkey:   Date.now(),\n\t\t\ttouch: Date.now(),\n\t\t\tswipe: Date.now()\n\t\t};\n\t\tthis.__history = {\n\t\t\tkey:   [],\n\t\t\ttouch: [],\n\t\t\tswipe: []\n\t\t};\n\t\tthis.__swipes  = {\n\t\t\t0: null, 1: null,\n\t\t\t2: null, 3: null,\n\t\t\t4: null, 5: null,\n\t\t\t6: null, 7: null,\n\t\t\t8: null, 9: null\n\t\t};\n\n\n\t\tthis.setDelay(settings.delay);\n\t\tthis.setKey(settings.key);\n\t\tthis.setKeyModifier(settings.keymodifier);\n\t\tthis.setTouch(settings.touch);\n\t\tthis.setSwipe(settings.swipe);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\t_instances.push(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.KEYMAP = {\n\n\t\t 8:  'backspace',\n\t\t 9:  'tab',\n\t\t13:  'enter',\n\t\t16:  'shift',\n\t\t17:  'ctrl',\n\t\t18:  'alt',\n\t\t19:  'pause',\n//\t\t20:  'capslock',\n\n\t\t27:  'escape',\n\t\t32:  'space',\n\t\t33:  'page-up',\n\t\t34:  'page-down',\n\t\t35:  'end',\n\t\t36:  'home',\n\n\t\t37:  'arrow-left',\n\t\t38:  'arrow-up',\n\t\t39:  'arrow-right',\n\t\t40:  'arrow-down',\n\n\t\t45:  'insert',\n\t\t46:  'delete',\n\n\t\t65:  'a',\n\t\t66:  'b',\n\t\t67:  'c',\n\t\t68:  'd',\n\t\t69:  'e',\n\t\t70:  'f',\n\t\t71:  'g',\n\t\t72:  'h',\n\t\t73:  'i',\n\t\t74:  'j',\n\t\t75:  'k',\n\t\t76:  'l',\n\t\t77:  'm',\n\t\t78:  'n',\n\t\t79:  'o',\n\t\t80:  'p',\n\t\t81:  'q',\n\t\t82:  'r',\n\t\t83:  's',\n\t\t84:  't',\n\t\t85:  'u',\n\t\t86:  'v',\n\t\t87:  'w',\n\t\t88:  'x',\n\t\t89:  'y',\n\t\t90:  'z',\n\n\t\t96:  '0',\n\t\t97:  '1',\n\t\t98:  '2',\n\t\t99:  '3',\n\t\t100: '4',\n\t\t101: '5',\n\t\t102: '6',\n\t\t103: '7',\n\t\t104: '8',\n\t\t105: '9',\n\t\t106: '*',\n\t\t107: '+',\n\t\t109: '-',\n\t\t110: '.',\n\t\t111: '/',\n\n\t\t112: 'f1',\n\t\t113: 'f2',\n\t\t114: 'f3',\n\t\t115: 'f4',\n\t\t116: 'f5',\n\t\t117: 'f6',\n\t\t118: 'f7',\n\t\t119: 'f8',\n\t\t120: 'f9',\n\t\t121: 'f10',\n\t\t122: 'f11',\n\t\t123: 'f12',\n\n//\t\t144: 'numlock',\n\t\t145: 'scroll'\n\n\t};\n\n\tClass.SPECIALMAP = {\n\n\t\t48:  [ '0', ')' ],\n\t\t49:  [ '1', '!' ],\n\t\t50:  [ '2', '@' ],\n\t\t51:  [ '3', '#' ],\n\t\t52:  [ '4', '$' ],\n\t\t53:  [ '5', '%' ],\n\t\t54:  [ '6', '^' ],\n\t\t55:  [ '7', '&' ],\n\t\t56:  [ '8', '*' ],\n\t\t57:  [ '9', '(' ],\n\n\t\t186: [ ';', ':' ],\n\t\t187: [ '=', '+' ],\n\t\t188: [ ',', '<' ],\n\t\t189: [ '-', '_' ],\n\t\t190: [ '.', '>' ],\n\t\t191: [ '/', '?' ],\n\t\t192: [ '`', '~' ],\n\n\t\t219: [ '[',  '{' ],\n\t\t220: [ '\\\\', '|' ],\n\t\t221: [ ']',  '}' ],\n\t\t222: [ '\\'', '\"' ]\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tdestroy: function() {\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var i = 0, il = _instances.length; i < il; i++) {\n\n\t\t\t\tif (_instances[i] === this) {\n\t\t\t\t\t_instances.splice(i, 1);\n\t\t\t\t\tfound = true;\n\t\t\t\t\til--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.unbind();\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.delay !== 0)           settings.delay       = this.delay;\n\t\t\tif (this.key !== false)         settings.key         = this.key;\n\t\t\tif (this.keymodifier !== false) settings.keymodifier = this.keymodifier;\n\t\t\tif (this.touch !== false)       settings.touch       = this.touch;\n\t\t\tif (this.swipe !== false)       settings.swipe       = this.swipe;\n\n\n\t\t\tif (this.__history.key.length > 0 || this.__history.touch.length > 0 || this.__history.swipe.length > 0) {\n\n\t\t\t\tblob.history = {};\n\n\t\t\t\tif (this.__history.key.length > 0) {\n\n\t\t\t\t\tblob.history.key = [];\n\n\t\t\t\t\tfor (var k = 0, kl = this.__history.key.length; k < kl; k++) {\n\t\t\t\t\t\tblob.history.key.push(this.__history.key[k]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.touch.length > 0) {\n\n\t\t\t\t\tblob.history.touch = [];\n\n\t\t\t\t\tfor (var t = 0, tl = this.__history.touch.length; t < tl; t++) {\n\t\t\t\t\t\tblob.history.touch.push(this.__history.touch[t]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.swipe.length > 0) {\n\n\t\t\t\t\tblob.history.swipe = [];\n\n\t\t\t\t\tfor (var s = 0, sl = this.__history.swipe.length; s < sl; s++) {\n\t\t\t\t\t\tblob.history.swipe.push(this.__history.swipe[s]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Input',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tsetDelay: function(delay) {\n\n\t\t\tdelay = typeof delay === 'number' ? delay : null;\n\n\n\t\t\tif (delay !== null) {\n\n\t\t\t\tthis.delay = delay;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetKey: function(key) {\n\n\t\t\tif (key === true || key === false) {\n\n\t\t\t\tthis.key = key;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetKeyModifier: function(keymodifier) {\n\n\t\t\tif (keymodifier === true || keymodifier === false) {\n\n\t\t\t\tthis.keymodifier = keymodifier;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetTouch: function(touch) {\n\n\t\t\tif (touch === true || touch === false) {\n\n\t\t\t\tthis.touch = touch;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetSwipe: function(swipe) {\n\n\t\t\tif (swipe === true || swipe === false) {\n\n\t\t\t\tthis.swipe = swipe;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.Storage": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.Storage"
				],
				"blob": {
					"tags": {
						"platform": "html"
					},
					"includes": [
						"lychee.event.Emitter"
					],
					"supports": "function (lychee, global) {\n\n\tif (typeof Storage !== 'undefined') {\n\n\t\tif (typeof global.localStorage === 'object' && typeof global.sessionStorage === 'object') {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\n\treturn false;\n\n}",
					"exports": "function (lychee, global) {\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _persistent = null;\n\tvar _temporary  = null;\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\t(function() {\n\n\t\tvar local = 'localStorage' in global;\n\t\tif (local === true) {\n\t\t\t_persistent = global.localStorage;\n\t\t}\n\n\t\tvar session = 'sessionStorage' in global;\n\t\tif (session === true) {\n\t\t\t_temporary = global.sessionStorage;\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (local)   methods.push('Persistent');\n\t\t\tif (session) methods.push('Temporary');\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.Storage: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.info('lychee.Storage: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\t})();\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _read_storage = function() {\n\n\t\tvar id   = this.id;\n\t\tvar blob = null;\n\n\n\t\tvar type = this.type;\n\t\tif (type === Class.TYPE.persistent) {\n\t\t\tblob = JSON.parse(_persistent.getItem(id));\n\t\t} else if (type === Class.TYPE.temporary) {\n\t\t\tblob = JSON.parse(_temporary.getItem(id));\n\t\t}\n\n\n\t\tif (blob !== null) {\n\n\t\t\tif (this.model === null) {\n\n\t\t\t\tif (blob['@model'] instanceof Object) {\n\t\t\t\t\tthis.model = blob['@model'];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar document = this.__document;\n\t\t\tif (document.index === 0) {\n\n\t\t\t\tif (blob['@document'] instanceof Object) {\n\t\t\t\t\tthis.__document = blob['@document'];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar objects = this.__objects;\n\t\t\tif (objects.length === 0 || objects.length !== blob['@objects'].length) {\n\n\t\t\t\tif (blob['@objects'] instanceof Array) {\n\n\t\t\t\t\tobjects = blob['@objects'];\n\t\t\t\t\tthis.__objects = [];\n\n\t\t\t\t\tfor (var o = 0, ol = objects.length; o < ol; o++) {\n\t\t\t\t\t\tthis.__objects.push(objects[o]);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.trigger('sync', [ this.__objects ]);\n\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _write_storage = function() {\n\n\t\tvar operations = this.__operations;\n\t\tif (operations.length !== 0) {\n\n\t\t\twhile (operations.length > 0) {\n\n\t\t\t\tvar operation = operations.shift();\n\t\t\t\tif (operation.type === 'insert') {\n\n\t\t\t\t\tthis.__document.index++;\n\t\t\t\t\tthis.__objects.push(operation.object);\n\t\t\t\t\tthis.trigger('insert', [ operation.index, operation.object ]);\n\n\t\t\t\t} else if (operation.type === 'update') {\n\n\t\t\t\t\tif (this.__objects[operation.index] !== operation.object) {\n\t\t\t\t\t\tthis.__objects[operation.index] = operation.object;\n\t\t\t\t\t\tthis.trigger('update', [ operation.index, operation.object ]);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (operation.type === 'remove') {\n\n\t\t\t\t\tthis.__document.index--;\n\t\t\t\t\tthis.__objects.splice(operation.index, 1);\n\t\t\t\t\tthis.trigger('remove', [ operation.index, operation.object ]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tthis.__document.time = Date.now();\n\n\n\t\t\tvar id   = this.id;\n\t\t\tvar blob = {\n\t\t\t\t'@document': this.__document,\n\t\t\t\t'@model':    this.model,\n\t\t\t\t'@objects':  this.__objects\n\t\t\t};\n\n\n\t\t\tvar type = this.type;\n\t\t\tif (type === Class.TYPE.persistent) {\n\n\t\t\t\tif (_persistent !== null) {\n\t\t\t\t\t_persistent.setItem(id, JSON.stringify(blob, null, '\\t'));\n\t\t\t\t}\n\n\t\t\t} else if (type === Class.TYPE.temporary) {\n\n\t\t\t\tif (_temporary !== null) {\n\t\t\t\t\t_temporary.setItem(id, JSON.stringify(blob, null, '\\t'));\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tthis.trigger('sync', [ this.__objects ]);\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _id = 0;\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.id    = 'lychee-Storage-' + _id++;\n\t\tthis.model = {};\n\t\tthis.type  = Class.TYPE.persistent;\n\n\t\tthis.__document   = { index: 0, time: Date.now() };\n\t\tthis.__objects    = [];\n\t\tthis.__operations = [];\n\n\n\t\tthis.setId(settings.id);\n\t\tthis.setModel(settings.model);\n\t\tthis.setType(settings.type);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\tsettings = null;\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\t_read_storage.call(this);\n\n\t};\n\n\n\tClass.TYPE = {\n\t\tpersistent: 0,\n\t\ttemporary:  1\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tsync: function(force) {\n\n\t\t\tforce = force === true;\n\n\n\t\t\tvar result = _read_storage.call(this);\n\t\t\tif (result === true) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (force === true) {\n\n\t\t\t\t\tthis.trigger('sync', [ this.__objects ]);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tif (blob.document instanceof Object) {\n\t\t\t\tthis.__document.index = blob.document.index;\n\t\t\t\tthis.__document.time  = blob.document.time;\n\t\t\t}\n\n\t\t\tif (blob.objects instanceof Array) {\n\n\t\t\t\tthis.__objects = [];\n\n\t\t\t\tfor (var o = 0, ol = blob.objects.length; o < ol; o++) {\n\n\t\t\t\t\tvar object = blob.objects[o];\n\t\t\t\t\tif (lychee.interfaceof(this.model, object)) {\n\t\t\t\t\t\tthis.__objects.push(object);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.id.substr(0, 15) !== 'lychee-Storage-') settings.id    = this.id;\n\t\t\tif (Object.keys(this.model).length !== 0)        settings.model = this.model;\n\t\t\tif (this.type !== Class.TYPE.persistent)         settings.type  = this.type;\n\n\n\t\t\tif (this.__document.index > 0) {\n\n\t\t\t\tblob.document = {};\n\t\t\t\tblob.document.index = this.__document.index;\n\t\t\t\tblob.document.time  = this.__document.time;\n\n\t\t\t}\n\n\t\t\tif (this.__objects.length > 0) {\n\n\t\t\t\tblob.objects = {};\n\n\t\t\t\tfor (var o = 0, ol = this.__objects.length; o < ol; o++) {\n\n\t\t\t\t\tvar object = this.__objects[o];\n\t\t\t\t\tif (object instanceof Object) {\n\t\t\t\t\t\tblob.objects.push(JSON.parse(JSON.stringify(object)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Storage',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tcreate: function() {\n\t\t\treturn lychee.extendunlink({}, this.model);\n\t\t},\n\n\t\tfilter: function(callback, scope) {\n\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : this;\n\n\n\t\t\tvar filtered = [];\n\n\t\t\tfor (var o = 0, ol = this.__objects.length; o < ol; o++) {\n\n\t\t\t\tvar object = this.__objects[o];\n\t\t\t\tif (callback !== null) {\n\n\t\t\t\t\tif (callback.call(scope, o, object) === true) {\n\t\t\t\t\t\tfiltered.push(object);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tfiltered.push(object);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn filtered;\n\n\t\t},\n\n\t\tinsert: function(object) {\n\n\t\t\t// This uses the diff method, because properties can be null\n\t\t\tobject = lychee.diff(this.model, object) === false ? object : null;\n\n\n\t\t\tif (object !== null) {\n\n\t\t\t\tvar index = this.__objects.indexOf(object);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.__operations.push({\n\t\t\t\t\t\ttype:   'insert',\n\t\t\t\t\t\tindex:  this.__objects.length,\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t});\n\n\n\t\t\t\t\t_write_storage.call(this);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tupdate: function(object) {\n\n\t\t\t// This uses the diff method, because properties can be null\n\t\t\tobject = lychee.diff(this.model, object) === false ? object : null;\n\n\n\t\t\tif (object !== null) {\n\n\t\t\t\tvar index = this.__objects.indexOf(object);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.__operations.push({\n\t\t\t\t\t\ttype:   'update',\n\t\t\t\t\t\tindex:  index,\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t});\n\n\n\t\t\t\t\t_write_storage.call(this);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tget: function(index) {\n\n\t\t\tindex  = typeof index === 'number' ? (index | 0) : null;\n\n\n\t\t\tif (index !== null) {\n\n\t\t\t\tvar object = this.__objects[index] || null;\n\t\t\t\tif (object !== null) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tremove: function(index, object) {\n\n\t\t\tindex = typeof index === 'number' ? (index | 0) : this.__objects.indexOf(object);\n\n\n\t\t\tif (index >= 0 && index < this.__objects.length) {\n\n\t\t\t\tthis.__operations.push({\n\t\t\t\t\ttype:   'remove',\n\t\t\t\t\tindex:  index,\n\t\t\t\t\tobject: this.__objects[index]\n\t\t\t\t});\n\n\n\t\t\t\t_write_storage.call(this);\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetId: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tthis.id = id;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetModel: function(model) {\n\n\t\t\tmodel = model instanceof Object ? model : null;\n\n\n\t\t\tif (model !== null) {\n\n\t\t\t\tthis.model = JSON.parse(JSON.stringify(model));\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetType: function(type) {\n\n\t\t\tif (lychee.enumof(Class.TYPE, type)) {\n\n\t\t\t\tthis.type = type;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.Viewport": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.Viewport"
				],
				"blob": {
					"tags": {
						"platform": "html"
					},
					"includes": [
						"lychee.event.Emitter"
					],
					"supports": "function (lychee, global) {\n\n\tif (typeof global.addEventListener === 'function') {\n\n\t\tif (typeof global.innerWidth === 'number' && typeof global.innerHeight === 'number') {\n\n\t\t\tif (typeof global.document !== 'undefined' && typeof global.document.getElementsByClassName === 'function') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\treturn false;\n\n}",
					"exports": "function (lychee, global) {\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _clock = {\n\t\torientationchange: null,\n\t\tresize:            0\n\t};\n\n\tvar _focusactive   = true;\n\tvar _reshapeactive = false;\n\tvar _reshapewidth  = global.innerWidth;\n\tvar _reshapeheight = global.innerHeight;\n\n\tvar _reshape_viewport = function() {\n\n\t\tif (_reshapeactive === true || (_reshapewidth === global.innerWidth && _reshapeheight === global.innerHeight)) {\n\t\t\t return false;\n\t\t}\n\n\n\t\t_reshapeactive = true;\n\n\n\n\t\t/*\n\t\t * ISSUE in Mobile WebKit:\n\t\t *\n\t\t * An issue occurs if width of viewport is higher than\n\t\t * the width of the viewport of future rotation state.\n\t\t *\n\t\t * This bugfix prevents the viewport to scale higher\n\t\t * than 1.0, even if the meta tag is correctly setup.\n\t\t */\n\n\t\tvar elements = global.document.getElementsByClassName('lychee-Renderer-canvas');\n\t\tfor (var e = 0, el = elements.length; e < el; e++) {\n\n\t\t\tvar element = elements[e];\n\n\t\t\telement.style.width  = '1px';\n\t\t\telement.style.height = '1px';\n\n\t\t}\n\n\n\n\t\t/*\n\t\t * ISSUE in Mobile Firefox and Mobile WebKit\n\t\t *\n\t\t * The reflow is too slow for an update, so we have\n\t\t * to lock the heuristic to only be executed once,\n\t\t * waiting for a second to let the reflow finish.\n\t\t */\n\n\t\tsetTimeout(function() {\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t_process_reshape.call(_instances[i], global.innerWidth, global.innerHeight);\n\t\t\t}\n\n\t\t\t_reshapewidth  = global.innerWidth;\n\t\t\t_reshapeheight = global.innerHeight;\n\t\t\t_reshapeactive = false;\n\n\t\t}, 1000);\n\n\t};\n\n\n\tvar _instances = [];\n\tvar _listeners = {\n\n\t\torientationchange: function() {\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t_process_orientation.call(_instances[i], global.orientation);\n\t\t\t}\n\n\t\t\t_clock.orientationchange = Date.now();\n\t\t\t_reshape_viewport();\n\n\t\t},\n\n\t\tresize: function() {\n\n\t\t\tif (_clock.orientationchange === null || (_clock.orientationchange !== null && _clock.orientationchange > _clock.resize)) {\n\n\t\t\t\t_clock.resize = Date.now();\n\t\t\t\t_reshape_viewport();\n\n\t\t\t}\n\n\t\t},\n\n\t\tfocus: function() {\n\n\t\t\tif (_focusactive === false) {\n\n\t\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t\t_process_show.call(_instances[i]);\n\t\t\t\t}\n\n\t\t\t\t_focusactive = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tblur: function() {\n\n\t\t\tif (_focusactive === true) {\n\n\t\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t\t_process_hide.call(_instances[i]);\n\t\t\t\t}\n\n\t\t\t\t_focusactive = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\tvar _enterFullscreen = null;\n\tvar _leaveFullscreen = null;\n\n\t(function() {\n\n\t\tvar resize      = 'onresize' in global;\n\t\tvar orientation = 'onorientationchange' in global;\n\t\tvar focus       = 'onfocus' in global;\n\t\tvar blur        = 'onblur' in global;\n\n\n\t\tif (typeof global.addEventListener === 'function') {\n\n\t\t\tif (resize)      global.addEventListener('resize',            _listeners.resize,            true);\n\t\t\tif (orientation) global.addEventListener('orientationchange', _listeners.orientationchange, true);\n\t\t\tif (focus)       global.addEventListener('focus',             _listeners.focus,             true);\n\t\t\tif (blur)        global.addEventListener('blur',              _listeners.blur,              true);\n\n\t\t}\n\n\n\t\tif (global.document && global.document.documentElement) {\n\n\t\t\tvar element = global.document.documentElement;\n\n\t\t\tif (typeof element.requestFullscreen === 'function' && typeof element.exitFullscreen === 'function') {\n\n\t\t\t\t_enterFullscreen = function() {\n\t\t\t\t\telement.requestFullscreen();\n\t\t\t\t};\n\n\t\t\t\t_leaveFullscreen = function() {\n\t\t\t\t\telement.exitFullscreen();\n\t\t\t\t};\n\n\t\t\t}\n\n\n\t\t\tif (_enterFullscreen === null || _leaveFullscreen === null) {\n\n\t\t\t\tvar prefixes = [ 'moz', 'ms', 'webkit' ];\n\t\t\t\tvar prefix   = null;\n\n\t\t\t\tfor (var p = 0, pl = prefixes.length; p < pl; p++) {\n\n\t\t\t\t\tif (typeof element[prefixes[p] + 'RequestFullScreen'] === 'function' && typeof document[prefixes[p] + 'CancelFullScreen'] === 'function') {\n\t\t\t\t\t\tprefix = prefixes[p];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (prefix !== null) {\n\n\t\t\t\t\t_enterFullscreen = function() {\n\t\t\t\t\t\telement[prefix + 'RequestFullScreen']();\n\t\t\t\t\t};\n\n\t\t\t\t\t_leaveFullscreen = function() {\n\t\t\t\t\t\tglobal.document[prefix + 'CancelFullScreen']();\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (resize)      methods.push('Resize');\n\t\t\tif (orientation) methods.push('Orientation');\n\t\t\tif (focus)       methods.push('Focus');\n\t\t\tif (blur)        methods.push('Blur');\n\n\t\t\tif (_enterFullscreen !== null && _leaveFullscreen !== null) {\n\t\t\t\tmethods.push('Fullscreen');\n\t\t\t}\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.Viewport: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.info('lychee.Viewport: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\t})();\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _process_show = function() {\n\n\t\tvar handled = false;\n\n\t\thandled = this.trigger('show', []) || handled;\n\n\n\t\tif (handled === true) {\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tthis.__history.show.push([ Date.now() ]);\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn handled;\n\n\t};\n\n\tvar _process_hide = function() {\n\n\t\tvar handled = false;\n\n\t\thandled = this.trigger('hide', []) || handled;\n\n\n\t\tif (handled === true) {\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tthis.__history.hide.push([ Date.now() ]);\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn handled;\n\n\t};\n\n\tvar _process_orientation = function(orientation) {\n\n\t\torientation = typeof orientation === 'number' ? orientation : null;\n\n\t\tif (orientation !== null) {\n\t\t\tthis.__orientation = orientation;\n\t\t}\n\n\t};\n\n\tvar _process_reshape = function(width, height) {\n\n\t\tif (width === this.width && height === this.height) {\n\t\t\treturn false;\n\t\t}\n\n\n\t\tthis.width  = width;\n\t\tthis.height = height;\n\n\n\n\t\tvar orientation = null;\n\t\tvar rotation    = null;\n\n\n\n\t\t/*\n\t\t *    TOP\n\t\t *  _______\n\t\t * |       |\n\t\t * |       |\n\t\t * |       |\n\t\t * |       |\n\t\t * |       |\n\t\t * [X][X][X]\n\t\t *\n\t\t *  BOTTOM\n\t\t */\n\n\t\tif (this.__orientation === 0) {\n\n\t\t\tif (width > height) {\n\n\t\t\t\torientation = 'landscape';\n\t\t\t\trotation    = 'landscape';\n\n\t\t\t} else {\n\n\t\t\t\torientation = 'portrait';\n\t\t\t\trotation    = 'portrait';\n\n\t\t\t}\n\n\n\n\t\t/*\n\t\t *  BOTTOM\n\t\t *\n\t\t * [X][X][X]\n\t\t * |       |\n\t\t * |       |\n\t\t * |       |\n\t\t * |       |\n\t\t * |_______|\n\t\t *\n\t\t *    TOP\n\t\t */\n\n\t\t} else if (this.__orientation === 180) {\n\n\t\t\tif (width > height) {\n\n\t\t\t\torientation = 'landscape';\n\t\t\t\trotation    = 'landscape';\n\n\t\t\t} else {\n\n\t\t\t\torientation = 'portrait';\n\t\t\t\trotation    = 'portrait';\n\n\t\t\t}\n\n\n\n\t\t/*\n\t\t *    ____________    B\n\t\t * T |            [x] O\n\t\t * O |            [x] T\n\t\t * P |____________[x] T\n\t\t *                    O\n\t\t *                    M\n\t\t */\n\n\t\t} else if (this.__orientation === 90) {\n\n\t\t\tif (width > height) {\n\n\t\t\t\torientation = 'portrait';\n\t\t\t\trotation    = 'landscape';\n\n\t\t\t} else {\n\n \t\t\t\torientation = 'landscape';\n\t\t\t\trotation    = 'portrait';\n\n\t\t\t}\n\n\n\n\t\t/*\n\t\t * B    ____________\n\t\t * O [x]            | T\n\t\t * T [x]            | O\n\t\t * T [x]____________| P\n\t\t * O\n\t\t * M\n\t\t */\n\n\t\t} else if (this.__orientation === -90) {\n\n\t\t\tif (width > height) {\n\n\t\t\t\torientation = 'portrait';\n\t\t\t\trotation    = 'landscape';\n\n\t\t\t} else {\n\n \t\t\t\torientation = 'landscape';\n\t\t\t\trotation    = 'portrait';\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tvar handled = false;\n\n\t\thandled = this.trigger('reshape', [ orientation, rotation ]) || handled;\n\n\n\t\tif (handled === true) {\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tthis.__history.reshape.push([ Date.now(), orientation, rotation ]);\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn handled;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.fullscreen = false;\n\t\tthis.width      = global.innerWidth;\n\t\tthis.height     = global.innerHeight;\n\n\t\tthis.__orientation = typeof global.orientation === 'number' ? global.orientation : 0;\n\t\tthis.__history     = {\n\t\t\tshow:    [],\n\t\t\thide:    [],\n\t\t\treshape: []\n\t\t};\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\t_instances.push(this);\n\n\n\t\tthis.setFullscreen(settings.fullscreen);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tdestroy: function() {\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var i = 0, il = _instances.length; i < il; i++) {\n\n\t\t\t\tif (_instances[i] === this) {\n\t\t\t\t\t_instances.splice(i, 1);\n\t\t\t\t\tfound = true;\n\t\t\t\t\til--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.unbind();\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.fullscreen !== false) settings.fullscreen = this.fullscreen;\n\n\n\t\t\tif (this.__history.show.length > 0 || this.__history.hide.length > 0 || this.__history.reshape.length > 0) {\n\n\t\t\t\tblob.history = {};\n\n\t\t\t\tif (this.__history.show.length > 0) {\n\n\t\t\t\t\tblob.history.show = [];\n\n\t\t\t\t\tfor (var s = 0, sl = this.__history.show.length; s < sl; s++) {\n\t\t\t\t\t\tblob.history.show.push(this.__history.show[s]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.hide.length > 0) {\n\n\t\t\t\t\tblob.history.hide = [];\n\n\t\t\t\t\tfor (var h = 0, hl = this.__history.hide.length; h < hl; h++) {\n\t\t\t\t\t\tblob.history.hide.push(this.__history.hide[h]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.reshape.length > 0) {\n\n\t\t\t\t\tblob.history.reshape = [];\n\n\t\t\t\t\tfor (var r = 0, rl = this.__history.reshape.length; r < rl; r++) {\n\t\t\t\t\t\tblob.history.reshape.push(this.__history.reshape[r]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Viewport',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tsetFullscreen: function(fullscreen) {\n\n\t\t\tif (fullscreen === true && this.fullscreen === false) {\n\n\t\t\t\tif (_enterFullscreen !== null) {\n\n\t\t\t\t\t_enterFullscreen();\n\t\t\t\t\tthis.fullscreen = true;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else if (fullscreen === false && this.fullscreen === true) {\n\n\t\t\t\tif (_leaveFullscreen !== null) {\n\n\t\t\t\t\t_leaveFullscreen();\n\t\t\t\t\tthis.fullscreen = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.Renderer": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.Renderer"
				],
				"blob": {
					"tags": {
						"platform": "html"
					},
					"supports": "function (lychee, global) {\n\n\t/*\n\t * Hint for check against undefined:\n\t *\n\t * typeof CanvasRenderingContext2D is:\n\t * > function in Chrome, Firefox, IE10\n\t * > object in Safari, Safari Mobile\n\t *\n\t */\n\n\n\tif (typeof global.document !== 'undefined' && typeof global.document.createElement === 'function') {\n\n\t\tif (typeof global.CanvasRenderingContext2D !== 'undefined') {\n\n\t\t\tvar canvas = global.document.createElement('canvas');\n\t\t\tif (typeof canvas.getContext === 'function') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\treturn false;\n\n}",
					"exports": "function (lychee, global, attachments) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _color_cache = {};\n\n\tvar _is_color = function(color) {\n\n\t\tif (typeof color === 'string') {\n\n\t\t\tif (color.match(/(#[AaBbCcDdEeFf0-9]{6})/) || color.match(/(#[AaBbCcDdEeFf0-9]{8})/)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _hex_to_rgba = function(hex) {\n\n\t\tif (_color_cache[hex] !== undefined) {\n\t\t\treturn _color_cache[hex];\n\t\t}\n\n\t\tvar rgba = [ 0, 0, 0, 255 ];\n\n\t\tif (typeof hex === 'string') {\n\n\t\t\tif (hex.length === 7) {\n\n\t\t\t\trgba[0] = parseInt(hex[1] + hex[2], 16);\n\t\t\t\trgba[1] = parseInt(hex[3] + hex[4], 16);\n\t\t\t\trgba[2] = parseInt(hex[5] + hex[6], 16);\n\t\t\t\trgba[3] = 255;\n\n\t\t\t} else if (hex.length === 9) {\n\n \t\t\t\trgba[0] = parseInt(hex[1] + hex[2], 16);\n\t\t\t\trgba[1] = parseInt(hex[3] + hex[4], 16);\n\t\t\t\trgba[2] = parseInt(hex[5] + hex[6], 16);\n\t\t\t\trgba[3] = parseInt(hex[7] + hex[8], 16);\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar color = 'rgba(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ',' + (rgba[3] / 255) + ')';\n\n\t\t_color_cache[hex] = color;\n\n\n\t\treturn color;\n\n\t};\n\n\n\n\t/*\n\t * STRUCTS\n\t */\n\n\tvar _buffer = function(width, height) {\n\n\t\tthis.width  = typeof width === 'number'  ? width  : 1;\n\t\tthis.height = typeof height === 'number' ? height : 1;\n\n\t\tthis.__buffer = global.document.createElement('canvas');\n\t\tthis.__ctx    = this.__buffer.getContext('2d');\n\n\t\tthis.__buffer.width  = this.width;\n\t\tthis.__buffer.height = this.height;\n\n\t};\n\n\t_buffer.prototype = {\n\n\t\tclear: function() {\n\n\t\t\tthis.__ctx.clearRect(0, 0, this.width, this.height);\n\n\t\t},\n\n\t\tresize: function(width, height) {\n\n\t\t\tthis.__buffer.width  = this.width;\n\t\t\tthis.__buffer.height = this.height;\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _id = 0;\n\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.alpha      = 1.0;\n\t\tthis.background = '#000000';\n\t\tthis.id         = 'lychee-Renderer-' + _id++;\n\t\tthis.width      = null;\n\t\tthis.height     = null;\n\t\tthis.offset     = { x: 0, y: 0 };\n\n\t\tthis.__canvas           = global.document.createElement('canvas');\n\t\tthis.__canvas.className = 'lychee-Renderer-canvas';\n\t\tthis.__ctx              = this.__canvas.getContext('2d');\n\t\tglobal.document.body.appendChild(this.__canvas);\n\n\n\t\tthis.setAlpha(settings.alpha);\n\t\tthis.setBackground(settings.background);\n\t\tthis.setId(settings.id);\n\t\tthis.setWidth(settings.width);\n\t\tthis.setHeight(settings.height);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.alpha !== 1.0)                           settings.alpha      = this.alpha;\n\t\t\tif (this.background !== '#000000')                settings.background = this.background;\n\t\t\tif (this.id.substr(0, 16) !== 'lychee-Renderer-') settings.id         = this.id;\n\t\t\tif (this.width !== null)                          settings.width      = this.width;\n\t\t\tif (this.height !== null)                         settings.height     = this.height;\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Renderer',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * SETTERS AND GETTERS\n\t\t */\n\n\t\tsetAlpha: function(alpha) {\n\n\t\t\talpha = typeof alpha === 'number' ? alpha : null;\n\n\n\t\t\tif (alpha !== null) {\n\n\t\t\t\tif (alpha >= 0 && alpha <= 1) {\n\t\t\t\t\tthis.alpha = alpha;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetBackground: function(color) {\n\n\t\t\tcolor = _is_color(color) === true ? color : null;\n\n\n\t\t\tif (color !== null) {\n\t\t\t\tthis.background = color;\n\t\t\t\tthis.__canvas.style.backgroundColor = color;\n\t\t\t}\n\n\t\t},\n\n\t\tsetId: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.__canvas.id = id;\n\t\t\t}\n\n\t\t},\n\n\t\tsetWidth: function(width) {\n\n\t\t\twidth = typeof width === 'number' ? width : null;\n\n\n\t\t\tif (width !== null) {\n\t\t\t\tthis.width = width;\n\t\t\t} else {\n\t\t\t\tthis.width = global.innerWidth;\n\t\t\t}\n\n\n\t\t\tthis.__canvas.width       = this.width;\n\t\t\tthis.__canvas.style.width = this.width + 'px';\n\t\t\tthis.offset.x             = this.__canvas.offsetLeft;\n\n\t\t},\n\n\t\tsetHeight: function(height) {\n\n\t\t\theight = typeof height === 'number' ? height : null;\n\n\n\t\t\tif (height !== null) {\n\t\t\t\tthis.height = height;\n\t\t\t} else {\n\t\t\t\tthis.height = global.innerHeight;\n\t\t\t}\n\n\n\t\t\tthis.__canvas.height       = this.height;\n\t\t\tthis.__canvas.style.height = this.height + 'px';\n\t\t\tthis.offset.y              = this.__canvas.offsetTop;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * BUFFER INTEGRATION\n\t\t */\n\n\t\tclear: function(buffer) {\n\n\t\t\tbuffer = buffer instanceof _buffer ? buffer : null;\n\n\n\t\t\tif (buffer !== null) {\n\n\t\t\t\tbuffer.clear();\n\n\t\t\t} else {\n\n\t\t\t\tvar ctx = this.__ctx;\n\n\t\t\t\tctx.fillStyle = this.background;\n\t\t\t\tctx.fillRect(0, 0, this.width, this.height);\n\n\t\t\t}\n\n\t\t},\n\n\t\tflush: function() {\n\n\t\t},\n\n\t\tcreateBuffer: function(width, height) {\n\t\t\treturn new _buffer(width, height);\n\t\t},\n\n\t\tsetBuffer: function(buffer) {\n\n\t\t\tbuffer = buffer instanceof _buffer ? buffer : null;\n\n\n\t\t\tif (buffer !== null) {\n\t\t\t\tthis.__ctx = buffer.__ctx;\n\t\t\t} else {\n\t\t\t\tthis.__ctx = this.__canvas.getContext('2d');\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * DRAWING API\n\t\t */\n\n\t\tdrawArc: function(x, y, start, end, radius, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\t\t\tvar pi2 = Math.PI * 2;\n\n\n\t\t\tctx.globalAlpha = this.alpha;\n\t\t\tctx.beginPath();\n\n\t\t\tctx.arc(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tradius,\n\t\t\t\tstart * pi2,\n\t\t\t\tend * pi2\n\t\t\t);\n\n\t\t\tif (background === false) {\n\t\t\t\tctx.lineWidth   = lineWidth;\n\t\t\t\tctx.strokeStyle = color;\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.fillStyle   = color;\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\tctx.closePath();\n\n\t\t},\n\n\t\tdrawBox: function(x1, y1, x2, y2, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\tctx.globalAlpha = this.alpha;\n\n\t\t\tif (background === false) {\n\t\t\t\tctx.lineWidth   = lineWidth;\n\t\t\t\tctx.strokeStyle = color;\n\t\t\t\tctx.strokeRect(x1, y1, x2 - x1, y2 - y1);\n\t\t\t} else {\n\t\t\t\tctx.fillStyle   = color;\n\t\t\t\tctx.fillRect(x1, y1, x2 - x1, y2 - y1);\n\t\t\t}\n\n\t\t},\n\n\t\tdrawBuffer: function(x1, y1, buffer) {\n\n\t\t\tbuffer = buffer instanceof _buffer ? buffer : null;\n\n\n\t\t\tif (buffer !== null) {\n\n\t\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t\tctx.globalAlpha = this.alpha;\n\t\t\t\tctx.drawImage(buffer.__buffer, x1, y1);\n\n\n\t\t\t\tif (lychee.debug === true) {\n\n\t\t\t\t\tthis.drawBox(\n\t\t\t\t\t\tx1,\n\t\t\t\t\t\ty1,\n\t\t\t\t\t\tx1 + buffer.width,\n\t\t\t\t\t\ty1 + buffer.height,\n\t\t\t\t\t\t'#00ff00',\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t1\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdrawCircle: function(x, y, radius, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\tctx.globalAlpha = this.alpha;\n\t\t\tctx.beginPath();\n\n\t\t\tctx.arc(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tradius,\n\t\t\t\t0,\n\t\t\t\tMath.PI * 2\n\t\t\t);\n\n\n\t\t\tif (background === false) {\n\t\t\t\tctx.lineWidth   = lineWidth;\n\t\t\t\tctx.strokeStyle = color;\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.fillStyle   = color;\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\tctx.closePath();\n\n\t\t},\n\n\t\tdrawLight: function(x, y, radius, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) ? _hex_to_rgba(color) : 'rgba(255,255,255,1.0)';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\tvar gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);\n\n\t\t\tgradient.addColorStop(0, color);\n\t\t\tgradient.addColorStop(1, 'rgba(0,0,0,0)');\n\n\n\t\t\tctx.globalAlpha = this.alpha;\n\t\t\tctx.beginPath();\n\n\t\t\tctx.arc(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tradius,\n\t\t\t\t0,\n\t\t\t\tMath.PI * 2\n\t\t\t);\n\n\n\t\t\tif (background === false) {\n\t\t\t\tctx.lineWidth   = lineWidth;\n\t\t\t\tctx.strokeStyle = gradient;\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.fillStyle   = gradient;\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\tctx.closePath();\n\n\t\t},\n\n\t\tdrawLine: function(x1, y1, x2, y2, color, lineWidth) {\n\n\t\t\tcolor     = _is_color(color) === true ? color : '#000000';\n\t\t\tlineWidth = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\tctx.globalAlpha = this.alpha;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x1, y1);\n\t\t\tctx.lineTo(x2, y2);\n\n\t\t\tctx.lineWidth   = lineWidth;\n\t\t\tctx.strokeStyle = color;\n\t\t\tctx.stroke();\n\n\t\t\tctx.closePath();\n\n\t\t},\n\n\t\tdrawTriangle: function(x1, y1, x2, y2, x3, y3, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\tctx.globalAlpha = this.alpha;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x1, y1);\n\t\t\tctx.lineTo(x2, y2);\n\t\t\tctx.lineTo(x3, y3);\n\t\t\tctx.lineTo(x1, y1);\n\n\t\t\tif (background === false) {\n\t\t\t\tctx.lineWidth   = lineWidth;\n\t\t\t\tctx.strokeStyle = color;\n\t\t\t\tctx.stroke();\n\t\t\t} else {\n\t\t\t\tctx.fillStyle   = color;\n\t\t\t\tctx.fill();\n\t\t\t}\n\n\t\t\tctx.closePath();\n\n\t\t},\n\n\t\t// points, x1, y1, [ ... x(a), y(a) ... ], [ color, background, lineWidth ]\n\t\tdrawPolygon: function(points, x1, y1) {\n\n\t\t\tvar l = arguments.length;\n\n\t\t\tif (points > 3) {\n\n\t\t\t\tvar optargs = l - (points * 2) - 1;\n\n\n\t\t\t\tvar color, background, lineWidth;\n\n\t\t\t\tif (optargs === 3) {\n\n\t\t\t\t\tcolor      = arguments[l - 3];\n\t\t\t\t\tbackground = arguments[l - 2];\n\t\t\t\t\tlineWidth  = arguments[l - 1];\n\n\t\t\t\t} else if (optargs === 2) {\n\n\t\t\t\t\tcolor      = arguments[l - 2];\n\t\t\t\t\tbackground = arguments[l - 1];\n\n\t\t\t\t} else if (optargs === 1) {\n\n\t\t\t\t\tcolor      = arguments[l - 1];\n\n\t\t\t\t}\n\n\n\t\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\t\tbackground = background === true;\n\t\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t\tctx.globalAlpha = this.alpha;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(x1, y1);\n\n\t\t\t\tfor (var p = 1; p < points; p++) {\n\n\t\t\t\t\tctx.lineTo(\n\t\t\t\t\t\targuments[1 + p * 2],\n\t\t\t\t\t\targuments[1 + p * 2 + 1]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tctx.lineTo(x1, y1);\n\n\t\t\t\tif (background === false) {\n\t\t\t\t\tctx.lineWidth   = lineWidth;\n\t\t\t\t\tctx.strokeStyle = color;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t} else {\n\t\t\t\t\tctx.fillStyle   = color;\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\n\t\t\t\tctx.closePath();\n\n\t\t\t}\n\n\t\t},\n\n\t\tdrawSprite: function(x1, y1, texture, map) {\n\n\t\t\ttexture = texture instanceof Texture ? texture : null;\n\t\t\tmap     = map instanceof Object      ? map     : null;\n\n\n\t\t\tif (texture !== null) {\n\n\t\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t\tctx.globalAlpha = this.alpha;\n\n\t\t\t\tif (map === null) {\n\n\t\t\t\t\tctx.drawImage(\n\t\t\t\t\t\ttexture.buffer,\n\t\t\t\t\t\tx1,\n\t\t\t\t\t\ty1\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif (lychee.debug === true) {\n\n\t\t\t\t\t\tthis.drawBox(\n\t\t\t\t\t\t\tx1,\n\t\t\t\t\t\t\ty1,\n\t\t\t\t\t\t\tx1 + map.w,\n\t\t\t\t\t\t\ty1 + map.h,\n\t\t\t\t\t\t\t'#ff0000',\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.drawImage(\n\t\t\t\t\t\ttexture.buffer,\n\t\t\t\t\t\tmap.x,\n\t\t\t\t\t\tmap.y,\n\t\t\t\t\t\tmap.w,\n\t\t\t\t\t\tmap.h,\n\t\t\t\t\t\tx1,\n\t\t\t\t\t\ty1,\n\t\t\t\t\t\tmap.w,\n\t\t\t\t\t\tmap.h\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdrawText: function(x1, y1, text, font, center) {\n\n\t\t\tfont   = font instanceof Font ? font : null;\n\t\t\tcenter = center === true;\n\n\n\t\t\tif (font !== null) {\n\n\t\t\t\tif (center === true) {\n\n\t\t\t\t\tvar dim = font.measure(text);\n\n\t\t\t\t\tx1 -= dim.realwidth / 2;\n\t\t\t\t\ty1 -= (dim.realheight - font.baseline) / 2;\n\n\t\t\t\t}\n\n\n\t\t\t\ty1 -= font.baseline / 2;\n\n\n\t\t\t\tvar margin  = 0;\n\t\t\t\tvar texture = font.texture;\n\t\t\t\tif (texture !== null) {\n\n\t\t\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t\t\tctx.globalAlpha = this.alpha;\n\n\t\t\t\t\tfor (t = 0, l = text.length; t < l; t++) {\n\n\t\t\t\t\t\tvar chr = font.measure(text[t]);\n\n\t\t\t\t\t\tif (lychee.debug === true) {\n\n\t\t\t\t\t\t\tthis.drawBox(\n\t\t\t\t\t\t\t\tx1 + margin,\n\t\t\t\t\t\t\t\ty1,\n\t\t\t\t\t\t\t\tx1 + margin + chr.realwidth,\n\t\t\t\t\t\t\t\ty1 + chr.height,\n\t\t\t\t\t\t\t\t'#00ff00',\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t1\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.drawImage(\n\t\t\t\t\t\t\ttexture.buffer,\n\t\t\t\t\t\t\tchr.x,\n\t\t\t\t\t\t\tchr.y,\n\t\t\t\t\t\t\tchr.width,\n\t\t\t\t\t\t\tchr.height,\n\t\t\t\t\t\t\tx1 + margin - font.spacing,\n\t\t\t\t\t\t\ty1,\n\t\t\t\t\t\t\tchr.width,\n\t\t\t\t\t\t\tchr.height\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tmargin += chr.realwidth + font.kerning;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * RENDERING API\n\t\t */\n\n\t\trenderEntity: function(entity, offsetX, offsetY) {\n\n\t\t\tif (typeof entity.render === 'function') {\n\n\t\t\t\tentity.render(\n\t\t\t\t\tthis,\n\t\t\t\t\toffsetX || 0,\n\t\t\t\t\toffsetY || 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.Jukebox": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Jukebox"
				],
				"blob": {
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _refresh_channels = function(amount) {\n\n\t\tvar sounds = [];\n\n\t\tfor (var a = 0; a < amount; a++) {\n\t\t\tsounds.push(null);\n\t\t}\n\n\t\tthis.__sounds = sounds;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.channels = 8;\n\t\tthis.music    = true;\n\t\tthis.sound    = true;\n\n\t\tthis.__music  = null;\n\t\tthis.__sounds = [\n\t\t\tnull, null,\n\t\t\tnull, null,\n\t\t\tnull, null,\n\t\t\tnull, null\n\t\t];\n\n\n\t\tthis.setChannels(settings.channels);\n\t\tthis.setMusic(settings.music);\n\t\tthis.setSound(settings.sound);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tplay: function(track) {\n\n\t\t\tif (track instanceof Music && this.music === true) {\n\n\t\t\t\tvar music = this.__music;\n\t\t\t\tif (music !== null) {\n\t\t\t\t\tmusic.stop();\n\t\t\t\t}\n\n\n\t\t\t\tthis.__music = track;\n\t\t\t\tthis.__music.play();\n\n\n\t\t\t\treturn true;\n\n\t\t\t} else if (track instanceof Sound && this.sound === true) {\n\n\t\t\t\tvar sounds = this.__sounds;\n\t\t\t\tfor (var s = 0, sl = sounds.length; s < sl; s++) {\n\n\t\t\t\t\tvar sound = sounds[s];\n\t\t\t\t\tif (sound === null) {\n\n\t\t\t\t\t\tsounds[s] = track.clone();\n\t\t\t\t\t\tsounds[s].play();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else if (sound.isIdle === true) {\n\n\t\t\t\t\t\tif (sound.url === track.url) {\n\t\t\t\t\t\t\tsound.play();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsounds[s] = track.clone();\n\t\t\t\t\t\t\tsounds[s].play();\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tstop: function(track) {\n\n\t\t\ttrack = (track instanceof Music || track instanceof Sound) ? track : null;\n\n\n\t\t\tvar found  = false;\n\t\t\tvar music  = this.__music;\n\t\t\tvar sounds = this.__sounds;\n\n\n\t\t\tvar s, sl, sound = null;\n\n\t\t\tif (track instanceof Music) {\n\n\t\t\t\tif (music === track) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tmusic.stop();\n\t\t\t\t}\n\n\n\t\t\t\tthis.__music = null;\n\n\t\t\t} else if (track instanceof Sound) {\n\n\t\t\t\tfor (s = 0, sl = sounds.length; s < sl; s++) {\n\n\t\t\t\t\tsound = sounds[s];\n\n\t\t\t\t\tif (sound !== null && sound.url === track.url && sound.isIdle === false) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tsound.stop();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if (track === null) {\n\n\t\t\t\tif (music !== null) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tmusic.stop();\n\t\t\t\t}\n\n\n\t\t\t\tfor (s = 0, sl = sounds.length; s < sl; s++) {\n\n\t\t\t\t\tsound = sounds[s];\n\n\t\t\t\t\tif (sound !== null && sound.isIdle === false) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tsound.stop();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\t\tsetChannels: function(channels) {\n\n\t\t\tchannels = typeof channels === 'number' ? channels : null;\n\n\n\t\t\tif (channels !== null) {\n\n\t\t\t\tthis.channels = channels;\n\n\t\t\t\t_refresh_channels.call(this, channels);\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetMusic: function(music) {\n\n\t\t\tif (music === true || music === false) {\n\n\t\t\t\tthis.music = music;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetSound: function(sound) {\n\n\t\t\tif (sound === true || sound === false) {\n\n\t\t\t\tthis.sound = sound;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.Loop": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Loop"
				],
				"blob": {
					"includes": [
						"lychee.event.Emitter"
					],
					"supports": "function (lychee, global) {\n\n\tif (typeof setInterval === 'function') {\n\t\treturn true;\n\t}\n\n\treturn false;\n\n}",
					"exports": "function (lychee, global) {\n\n    var _instances = [];\n \tvar _id        = 0;\n\n\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _listeners = {\n\n\t\tinterval: function() {\n\n\t\t\tvar now = Date.now();\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\n\t\t\t\tvar instance = _instances[i];\n\t\t\t\tvar clock    = now - instance.__start;\n\n\t\t\t\t_update_loop.call(instance, clock);\n\t\t\t\t_render_loop.call(instance, clock);\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\t(function(delta) {\n\n\t\tvar interval = typeof global.setInterval === 'function';\n\t\tif (interval === true) {\n\t\t\tglobal.setInterval(_listeners.interval, delta);\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (interval) methods.push('setInterval');\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.game.Loop: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.log('lychee.game.Loop: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\t})((1000 / 60) | 0);\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _update_loop;\n\n\tif (lychee.debug === true) {\n\n\t\t_update_loop = function(clock) {\n\n\t\t\tif (this.__state !== 1) return;\n\n\n\t\t\tvar delta = clock - this.__updateclock;\n\t\t\tif (delta >= this.__updatedelay) {\n\n\t\t\t\tthis.trigger('update', [ clock, delta ]);\n\n\n\t\t\t\tfor (var iid in this.__intervals) {\n\n\t\t\t\t\tvar interval = this.__intervals[iid];\n\n\t\t\t\t\tif (clock >= interval.clock) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tinterval.callback.call(\n\t\t\t\t\t\t\t\tinterval.scope,\n\t\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\t\tclock - interval.clock,\n\t\t\t\t\t\t\t\tinterval.step++\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\t\tlychee.Debugger.report(null, err, null);\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tinterval.clock = clock + interval.delta;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var tid in this.__timeouts) {\n\n\t\t\t\t\tvar timeout = this.__timeouts[tid];\n\t\t\t\t\tif (clock >= timeout.clock) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\ttimeout.callback.call(\n\t\t\t\t\t\t\t\ttimeout.scope,\n\t\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\t\tclock - timeout.clock\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\t\tlychee.Debugger.report(null, err, null);\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tdelete this.__timeouts[tid];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tthis.__updateclock = clock;\n\n\t\t\t}\n\n\t\t};\n\n\n\t} else {\n\n\t\t_update_loop = function(clock) {\n\n\t\t\tif (this.__state !== 1) return;\n\n\n\t\t\tvar delta = clock - this.__updateclock;\n\t\t\tif (delta >= this.__updatedelay) {\n\n\t\t\t\tthis.trigger('update', [ clock, delta ]);\n\n\n\t\t\t\tfor (var iid in this.__intervals) {\n\n\t\t\t\t\tvar interval = this.__intervals[iid];\n\n\t\t\t\t\tif (clock >= interval.clock) {\n\n\t\t\t\t\t\tinterval.callback.call(\n\t\t\t\t\t\t\tinterval.scope,\n\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\tclock - interval.clock,\n\t\t\t\t\t\t\tinterval.step++\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tinterval.clock = clock + interval.delta;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var tid in this.__timeouts) {\n\n\t\t\t\t\tvar timeout = this.__timeouts[tid];\n\t\t\t\t\tif (clock >= timeout.clock) {\n\n\t\t\t\t\t\ttimeout.callback.call(\n\t\t\t\t\t\t\ttimeout.scope,\n\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\tclock - timeout.clock\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdelete this.__timeouts[tid];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tthis.__updateclock = clock;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\n\tvar _render_loop = function(clock) {\n\n\t\tif (this.__state !== 1) return;\n\n\n\t\tvar delta = clock - this.__renderclock;\n\t\tif (delta >= this.__renderdelay) {\n\n\t\t\tthis.trigger('render', [ clock, delta ]);\n\n\n\t\t\tthis.__renderclock = clock;\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.update = 40;\n\t\tthis.render = 40;\n\n\t\tthis.__timeouts  = {};\n\t\tthis.__intervals = {};\n\n\t\tthis.__pause       = 0;\n\t\tthis.__state       = 1;\n\t\tthis.__start       = Date.now();\n\t\tthis.__renderclock = 0;\n\t\tthis.__renderdelay = 1000 / this.update;\n\t\tthis.__updateclock = 0;\n\t\tthis.__updatedelay = 1000 / this.render;\n\n\n\t\tthis.setUpdate(settings.update);\n\t\tthis.setRender(settings.render);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\t_instances.push(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.update !== 40) settings.update = this.update;\n\t\t\tif (this.render !== 40) settings.render = this.render;\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Loop',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tstart: function() {\n\n\t\t\tthis.__state = 1;\n\t\t\tthis.__start = Date.now();\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis.__state = 0;\n\n\t\t},\n\n\t\tpause: function() {\n\n\t\t\tthis.__state = 0;\n\t\t\tthis.__pause = Date.now() - this.__start;\n\n\t\t},\n\n\t\tresume: function() {\n\n\t\t\tthis.__state = 1;\n\t\t\tthis.__start = Date.now() - this.__pause;\n\t\t\tthis.__pause = 0;\n\n\t\t},\n\n\t\tsetTimeout: function(delta, callback, scope) {\n\n\t\t\tdelta    = typeof delta === 'number'    ? delta    : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : global;\n\n\n\t\t\tif (delta === null || callback === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\n\t\t\tvar id = _id++;\n\n\t\t\tthis.__timeouts[id] = {\n\t\t\t\tclock:    this.__updateclock + delta,\n\t\t\t\tcallback: callback,\n\t\t\t\tscope:    scope\n\t\t\t};\n\n\n\t\t\treturn id;\n\n\t\t},\n\n\t\tremoveTimeout: function(id) {\n\n\t\t\tid = typeof id === 'number' ? id : null;\n\n\n\t\t\tif (id !== null && this.__timeouts[id] !== undefined) {\n\n\t\t\t\tdelete this.__timeouts[id];\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetInterval: function(delta, callback, scope) {\n\n\t\t\tdelta    = typeof delta === 'number'    ? delta    : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : global;\n\n\n\t\t\tif (delta === null || callback === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\n\t\t\tvar id = _id++;\n\n\t\t\tthis.__intervals[id] = {\n\t\t\t\tclock:    this.__updateclock + delta,\n\t\t\t\tdelta:    delta,\n\t\t\t\tstep:     1,\n\t\t\t\tcallback: callback,\n\t\t\t\tscope:    scope\n\t\t\t};\n\n\n\t\t\treturn id;\n\n\t\t},\n\n\t\tremoveInterval: function(id) {\n\n\t\t\tid = typeof id === 'number' ? id : null;\n\n\n\t\t\tif (id !== null && this.__intervals[id] !== undefined) {\n\n\t\t\t\tdelete this.__intervals[id];\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetUpdate: function(update) {\n\n\t\t\tupdate = typeof update === 'number' ? update : null;\n\n\n\t\t\tif (update !== null && update > 0) {\n\n\t\t\t\tthis.update        = update;\n\t\t\t\tthis.__updatedelay = 1000 / update;\n\n\t\t\t\treturn true;\n\n\t\t\t} else if (update === 0) {\n\n\t\t\t\tthis.update        = update;\n\t\t\t\tthis.__updatedelay = Infinity;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetRender: function(render) {\n\n\t\t\trender = typeof render === 'number' ? render : null;\n\n\n\t\t\tif (render !== null && render > 0) {\n\n\t\t\t\tthis.render        = render;\n\t\t\t\tthis.__renderdelay = 1000 / render;\n\n\t\t\t\treturn true;\n\n\t\t\t} else if (render === 0) {\n\n\t\t\t\tthis.render        = render;\n\t\t\t\tthis.__renderdelay = Infinity;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.State": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.State"
				],
				"blob": {
					"requires": [
						"lychee.game.Layer",
						"lychee.game.Logic",
						"lychee.ui.Layer"
					],
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _trace_entity_offset = function(entity, layer, offsetX, offsetY) {\n\n\t\tif (offsetX === undefined || offsetY === undefined) {\n\n\t\t\tthis.x  = 0;\n\t\t\tthis.y  = 0;\n\t\t\toffsetX = layer.position.x;\n\t\t\toffsetY = layer.position.y;\n\n\t\t}\n\n\n\t\tif (layer === entity) {\n\n\t\t\tthis.x = offsetX;\n\t\t\tthis.y = offsetY;\n\n\t\t\treturn true;\n\n\t\t} else if (layer.entities !== undefined) {\n\n\t\t\tvar entities = layer.entities;\n\t\t\tfor (var e = entities.length - 1; e >= 0; e--) {\n\n\t\t\t\tvar dx = layer.offset.x + entities[e].position.x;\n\t\t\t\tvar dy = layer.offset.y + entities[e].position.y;\n\n\n\t\t\t\tvar result = _trace_entity_offset.call(\n\t\t\t\t\tthis,\n\t\t\t\t\tentity,\n\t\t\t\t\tentities[e],\n\t\t\t\t\toffsetX + dx,\n\t\t\t\t\toffsetY + dy\n\t\t\t\t);\n\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(main) {\n\n\t\tthis.main     = main          || null;\n\t\tthis.client   = main.client   || null;\n\t\tthis.input    = main.input    || null;\n\t\tthis.jukebox  = main.jukebox  || null;\n\t\tthis.loop     = main.loop     || null;\n\t\tthis.renderer = main.renderer || null;\n\n\n\t\tthis.__layers  = {};\n\t\tthis.__logics  = [];\n\t\tthis.__focus   = null;\n\t\tthis.__touches = [\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } }\n\t\t];\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * STATE API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tif (blob.layers) {\n\n\t\t\t\tfor (var laid in blob.layers) {\n\t\t\t\t\tthis.setLayer(laid, lychee.deserialize(blob.layers[laid]));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (blob.logics) {\n\n\t\t\t\tfor (var l = 0, ll = blob.logics.length; b < bl; b++) {\n\t\t\t\t\tthis.addLogic(lychee.deserialize(blob.logics[l]));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = this.main !== null ? '#MAIN' : null;\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (Object.keys(this.__layers).length > 0) {\n\n\t\t\t\tblob.layers = {};\n\n\t\t\t\tfor (var lid in this.__layers) {\n\t\t\t\t\tblob.layers[lid] = lychee.serialize(this.__layers[lid]);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (this.__logics.length > 0) {\n\n\t\t\t\tblob.logics = [];\n\n\t\t\t\tfor (var l = 0, ll = this.__logics.length; l < ll; l++) {\n\t\t\t\t\tblob.logics.push(lychee.serialize(this.__logics[l]));\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.State',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\t\tenter: function(data) {\n\n\t\t\tvar input = this.input;\n\t\t\tif (input !== null) {\n\t\t\t\tinput.bind('key',   this.processKey,   this);\n\t\t\t\tinput.bind('touch', this.processTouch, this);\n\t\t\t\tinput.bind('swipe', this.processSwipe, this);\n\t\t\t}\n\n\t\t\tvar logics = this.__logics;\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\t\t\t\tlogics[l].enter(data);\n\t\t\t}\n\n\t\t},\n\n\t\tleave: function() {\n\n\t\t\tvar focus = this.__focus;\n\t\t\tif (focus !== null) {\n\t\t\t\tfocus.trigger('blur');\n\t\t\t}\n\n\n\t\t\tfor (var t = 0, tl = this.__touches.length; t < tl; t++) {\n\n\t\t\t\tvar touch = this.__touches[t];\n\t\t\t\tif (touch.entity !== null) {\n\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tthis.__focus = null;\n\n\n\t\t\tvar input = this.input;\n\t\t\tif (input !== null) {\n\t\t\t\tinput.unbind('swipe', this.processSwipe, this);\n\t\t\t\tinput.unbind('touch', this.processTouch, this);\n\t\t\t\tinput.unbind('key',   this.processKey,   this);\n\t\t\t}\n\n\t\t\tvar logics = this.__logics;\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\t\t\t\tlogics[l].leave();\n\t\t\t}\n\n\t\t},\n\n\t\tshow: function() {\n\n\t\t},\n\n\t\treshape: function() {\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tvar position = {\n\t\t\t\t\tx: 1/2 * renderer.width,\n\t\t\t\t\ty: 1/2 * renderer.height\n\t\t\t\t};\n\n\t\t\t\tfor (var id in this.__layers) {\n\t\t\t\t\tthis.__layers[id].setPosition(position);\n\t\t\t\t\tthis.__layers[id].reshape();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\thide: function() {\n\n\t\t},\n\n\t\trender: function(clock, delta, custom) {\n\n\t\t\tcustom = custom === true;\n\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tif (custom === false) {\n\t\t\t\t\trenderer.clear();\n\t\t\t\t}\n\n\n\t\t\t\tfor (var id in this.__layers) {\n\n\t\t\t\t\tvar layer = this.__layers[id];\n\t\t\t\t\tif (layer.visible === false) continue;\n\n\t\t\t\t\tlayer.render(\n\t\t\t\t\t\trenderer,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (custom === false) {\n\t\t\t\t\trenderer.flush();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tfor (var id in this.__layers) {\n\n\t\t\t\tvar layer = this.__layers[id];\n\t\t\t\tif (layer.visible === false) continue;\n\n\t\t\t\tlayer.update(clock, delta);\n\n\t\t\t}\n\n\n\t\t\tvar logics = this.__logics;\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\t\t\t\tlogics[l].update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * LAYER API\n\t\t */\n\n\t\tsetLayer: function(id, layer) {\n\n\t\t\tid    = typeof id === 'string'                                                                       ? id    : null;\n\t\t\tlayer = (lychee.interfaceof(lychee.game.Layer, layer) || lychee.interfaceof(lychee.ui.Layer, layer)) ? layer : null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tif (layer !== null) {\n\n\t\t\t\t\tthis.__layers[id] = layer;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetLayer: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__layers[id] !== undefined) {\n\t\t\t\treturn this.__layers[id];\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tqueryLayer: function(id, query) {\n\n\t\t\tid    = typeof id === 'string'    ? id    : null;\n\t\t\tquery = typeof query === 'string' ? query : null;\n\n\n\t\t\tif (id !== null && query !== null) {\n\n\t\t\t\tvar layer = this.getLayer(id);\n\t\t\t\tif (layer !== null) {\n\n\t\t\t\t\tvar entity = layer;\n\t\t\t\t\tvar ids    = query.split(' > ');\n\n\t\t\t\t\tfor (var i = 0, il = ids.length; i < il; i++) {\n\n\t\t\t\t\t\tentity = entity.getEntity(ids[i]);\n\n\t\t\t\t\t\tif (entity === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn entity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tremoveLayer: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__layers[id] !== undefined) {\n\n\t\t\t\tdelete this.__layers[id];\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\t/*\n\t\t * LOGIC API\n\t\t */\n\n\t\taddLogic: function(logic) {\n\n\t\t\tlogic = lychee.interfaceof(lychee.game.Logic, logic) ? logic : null;\n\n\n\t\t\tif (logic !== null) {\n\n\t\t\t\tvar index = this.__logics.indexOf(logic);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.__logics.push(logic);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveLogic: function(logic) {\n\n\t\t\tlogic = lychee.interfaceof(lychee.game.Logic, logic) ? logic : null;\n\n\n\t\t\tif (logic !== null) {\n\n\t\t\t\tvar index = this.__logics.indexOf(logic);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.__logics.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetLogics: function(logics) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (logics instanceof Array) {\n\n\t\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\n\t\t\t\t\tvar result = this.addLogic(logics[l]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveLogics: function() {\n\n\t\t\tvar logics = this.__logics;\n\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\n\t\t\t\tthis.removeLogic(logics[l]);\n\n\t\t\t\tll--;\n\t\t\t\tl--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * EVENT API\n\t\t */\n\n\t\tprocessKey: function(key, name, delta) {\n\n\t\t\tvar focus = this.__focus;\n\t\t\tif (focus !== null) {\n\n\t\t\t\tvar result = focus.trigger('key', [ key, name, delta ]);\n\t\t\t\tif (result === true && key === 'return' && focus.state === 'default') {\n\t\t\t\t\tthis.__focus = null;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tprocessTouch: function(id, position, delta) {\n\n\t\t\tvar args = [ id, {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t}, delta ];\n\n\n\t\t\tvar x = position.x;\n\t\t\tvar y = position.y;\n\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tx -= renderer.offset.x;\n\t\t\t\ty -= renderer.offset.y;\n\n\t\t\t}\n\n\n\t\t\tvar touch_layer  = null;\n\t\t\tvar touch_entity = null;\n\n\t\t\tfor (var lid in this.__layers) {\n\n\t\t\t\tvar layer = this.__layers[lid];\n\t\t\t\tif (layer.visible === false) continue;\n\n\t\t\t\tif (lychee.interfaceof(lychee.ui.Layer, layer)) {\n\n\t\t\t\t\targs[1].x = x - layer.position.x;\n\t\t\t\t\targs[1].y = y - layer.position.y;\n\n\n\t\t\t\t\tvar result = layer.trigger('touch', args);\n\t\t\t\t\tif (result !== true && result !== false && result !== null) {\n\n\t\t\t\t\t\ttouch_entity = result;\n\t\t\t\t\t\ttouch_layer  = layer;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar old_focus = this.__focus;\n\t\t\tvar new_focus = touch_entity;\n\n\t\t\t// 1. Reset Touch trace data if no Entity was touched\n\t\t\tif (new_focus === null) {\n\t\t\t\tthis.__touches[id].entity = null;\n\t\t\t\tthis.__touches[id].layer  = null;\n\t\t\t}\n\n\n\t\t\t// 2. Change Focus State Interaction\n\t\t\tif (new_focus !== old_focus) {\n\n\t\t\t\tif (old_focus !== null) {\n\n\t\t\t\t\tif (old_focus.state !== 'default') {\n\t\t\t\t\t\told_focus.trigger('blur');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (new_focus !== null) {\n\n\t\t\t\t\tif (new_focus.state === 'default') {\n\t\t\t\t\t\tnew_focus.trigger('focus');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tthis.__focus = new_focus;\n\n\t\t\t}\n\n\n\t\t\t// 3. Prepare UI Swipe event\n\t\t\tif (touch_entity !== null) {\n\n\t\t\t\tvar touch = this.__touches[id];\n\n\t\t\t\ttouch.entity   = new_focus;\n\t\t\t\ttouch.layer    = touch_layer;\n\n\n\t\t\t\t// TODO: Fix intelligent reshape() calls for resizing entities on touch events\n\t\t\t\tthis.loop.setTimeout(300, function() {\n\t\t\t\t\tthis.reshape();\n\t\t\t\t}, touch.layer);\n\n\n\t\t\t\t_trace_entity_offset.call(\n\t\t\t\t\ttouch.offset,\n\t\t\t\t\ttouch.entity,\n\t\t\t\t\ttouch.layer\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\t\tprocessSwipe: function(id, type, position, delta, swipe) {\n\n\t\t\tvar touch = this.__touches[id];\n\t\t\tif (touch.entity !== null) {\n\n\t\t\t\tif (touch.layer.visible === false) return;\n\n\n\t\t\t\tvar args   = [ id, type, position, delta, swipe ];\n\t\t\t\tvar result = false;\n\n\t\t\t\tvar renderer = this.renderer;\n\t\t\t\tif (renderer !== null) {\n\n\t\t\t\t\targs[2].x -= renderer.offset.x;\n\t\t\t\t\targs[2].y -= renderer.offset.y;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (type === 'start') {\n\n\t\t\t\t\t_trace_entity_offset.call(\n\t\t\t\t\t\ttouch.offset,\n\t\t\t\t\t\ttouch.entity,\n\t\t\t\t\t\ttouch.layer\n\t\t\t\t\t);\n\n\n\t\t\t\t\targs[2].x -= touch.offset.x;\n\t\t\t\t\targs[2].y -= touch.offset.y;\n\t\t\t\t\tresult     = touch.entity.trigger('swipe', args);\n\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t\t}\n\n\t\t\t\t} else if (type === 'move') {\n\n\t\t\t\t\targs[2].x -= touch.offset.x;\n\t\t\t\t\targs[2].y -= touch.offset.y;\n\t\t\t\t\tresult     = touch.entity.trigger('swipe', args);\n\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t\t}\n\n\t\t\t\t} else if (type === 'end') {\n\n\t\t\t\t\targs[2].x -= touch.offset.x;\n\t\t\t\t\targs[2].y -= touch.offset.y;\n\t\t\t\t\tresult     = touch.entity.trigger('swipe', args);\n\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.net.Client": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.net.Client"
				],
				"blob": {
					"tags": {
						"platform": "html"
					},
					"requires": [
						"lychee.net.Service"
					],
					"includes": [
						"lychee.event.Emitter"
					],
					"supports": "function (lychee, global) {\n\n\tif (typeof WebSocket !== 'undefined') {\n\t\treturn true;\n\t}\n\n\n\treturn false;\n\n}",
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _socket_handler = function(url) {\n\n\t\tvar that = this;\n\n\n\t\tthis.__socket = new WebSocket(url);\n\n\n\t\tif (typeof ArrayBuffer !== 'undefined' && typeof this.__socket.binaryType !== 'undefined') {\n\t\t\tthis.__socket.binaryType = 'arraybuffer';\n\t\t\tthis.__isBinary = true;\n\t\t}\n\n\n\t\tthis.__socket.onopen = function() {\n\n\t\t\tthat.__isRunning = true;\n\t\t\tthat.trigger('connect');\n\n\t\t};\n\n\t\tthis.__socket.onmessage = function(event) {\n\n\t\t\tvar blob = null;\n\t\t\tif (that.__isBinary === true && event.data instanceof ArrayBuffer) {\n\n\t\t\t\tvar bytes = new Uint8Array(event.data);\n\t\t\t\tblob = String.fromCharCode.apply(null, bytes);\n\n\t\t\t\t_receive_handler.call(that, blob, true);\n\n\t\t\t} else {\n\n\t\t\t\tblob = event.data;\n\n\t\t\t\t_receive_handler.call(that, blob, false);\n\n\t\t\t}\n\n\t\t};\n\n\n\t\t// WebSocket Close frame is standardized,\n\t\t// no deserialization required.\n\n\t\tthis.__socket.onclose = function(event) {\n\n\t\t\tthat.__socket    = null;\n\t\t\tthat.__isRunning = false;\n\t\t\t_cleanup_services.call(that);\n\n\t\t\tthat.trigger('disconnect', [ event.code, event.reason ]);\n\n\n\t\t\tif (that.reconnect > 0) {\n\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tthat.listen(that.port, that.host);\n\t\t\t\t}, that.reconnect);\n\n\t\t\t}\n\n\t\t};\n\n\t};\n\n\tvar _receive_handler = function(blob, isBinary) {\n\n\t\tvar data = null;\n\t\ttry {\n\t\t\tdata = this.__decoder(blob);\n\t\t} catch(e) {\n\t\t\t// Unsupported data encoding\n\t\t\treturn false;\n\t\t}\n\n\n\t\tif (data instanceof Object && typeof data._serviceId === 'string') {\n\n\t\t\tvar service = this.getService(data._serviceId);\n\t\t\tvar event   = data._serviceEvent  || null;\n\t\t\tvar method  = data._serviceMethod || null;\n\n\n\t\t\tif (method !== null) {\n\n\t\t\t\tif (method.charAt(0) === '@') {\n\n\t\t\t\t\tif (method === '@plug') {\n\t\t\t\t\t\t_plug_service.call(this,   data._serviceId, service);\n\t\t\t\t\t} else if (method === '@unplug') {\n\t\t\t\t\t\t_unplug_service.call(this, data._serviceId, service);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (service !== null && typeof service[method] === 'function') {\n\n\t\t\t\t\t// Remove data frame service header\n\t\t\t\t\tdelete data._serviceId;\n\t\t\t\t\tdelete data._serviceMethod;\n\n\t\t\t\t\tservice[method](data);\n\n\t\t\t\t}\n\n\t\t\t} else if (event !== null) {\n\n\t\t\t\tif (service !== null && typeof service.trigger === 'function') {\n\n\t\t\t\t\t// Remove data frame service header\n\t\t\t\t\tdelete data._serviceId;\n\t\t\t\t\tdelete data._serviceEvent;\n\n\t\t\t\t\tservice.trigger(event, [ data ]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.trigger('receive', [ data ]);\n\n\t\t}\n\n\n\t\treturn true;\n\n\t};\n\n\tvar _is_service_waiting = function(service) {\n\n\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\tif (this.__services.waiting[w] === service) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _is_service_active = function(service) {\n\n\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\tif (this.__services.active[a] === service) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _plug_service = function(id, service) {\n\n\t\tid = typeof id === 'string' ? id : null;\n\n\t\tif (id === null || service === null) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar found = false;\n\n\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\tif (this.__services.waiting[w] === service) {\n\t\t\t\tthis.__services.waiting.splice(w, 1);\n\t\t\t\tfound = true;\n\t\t\t\twl--;\n\t\t\t\tw--;\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (found === true) {\n\n\t\t\tthis.__services.active.push(service);\n\n\t\t\tservice.trigger('plug', []);\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tconsole.log('lychee.net.Client: Remote plugged in Service (' + id + ')');\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar _unplug_service = function(id, service) {\n\n\t\tid = typeof id === 'string' ? id : null;\n\n\t\tif (id === null || service === null) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar found = false;\n\n\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\tif (this.__services.active[a] === service) {\n\t\t\t\tthis.__services.active.splice(a, 1);\n\t\t\t\tfound = true;\n\t\t\t\tal--;\n\t\t\t\ta--;\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (found === true) {\n\n\t\t\tservice.trigger('unplug', []);\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tconsole.log('lychee.net.Client: Remote unplugged Service (' + id + ')');\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar _cleanup_services = function() {\n\n\t\tvar services = this.__services.active;\n\n\t\tfor (var s = 0; s < services.length; s++) {\n\t\t\tservices[s].trigger('unplug', []);\n\t\t}\n\n\n\t\tthis.__services.active  = [];\n\t\tthis.__services.waiting = [];\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.port      = 1337;\n\t\tthis.host      = 'localhost';\n\t\tthis.reconnect = 0;\n\n\n\t\tthis.__encoder = settings.encoder instanceof Function ? settings.encoder : JSON.stringify;\n\t\tthis.__decoder = settings.decoder instanceof Function ? settings.decoder : JSON.parse;\n\t\tthis.__socket  = null;\n\t\tthis.__services  = {\n\t\t\twaiting: [], // Waiting Services need to be verified from Remote\n\t\t\tactive:  []  // Active Services for allowed interaction\n\t\t};\n\n\t\tthis.__isBinary  = false;\n\t\tthis.__isRunning = false;\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tlisten: function(port, host) {\n\n\t\t\tif (this.__socket !== null) return false;\n\n\n\t\t\tthis.port = typeof port === 'number' ? port : this.port;\n\t\t\tthis.host = typeof host === 'string' ? host : this.host;\n\n\n\t\t\tif (this.__isRunning === true) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tconsole.log('lychee.net.Client: Listening on ' + this.host + ':' + this.port);\n\t\t\t}\n\n\n\t\t\tvar url = 'ws://' + this.host + ':' + this.port;\n\n\t\t\t_socket_handler.call(this, url);\n\n\t\t},\n\n\t\tsend: function(data, service) {\n\n\t\t\tdata    = data instanceof Object    ? data    : null;\n\t\t\tservice = service instanceof Object ? service : null;\n\n\n\t\t\tif (data === null || this.__isRunning === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tif (service !== null) {\n\n\t\t\t\tif (typeof service.id     === 'string') data._serviceId     = service.id;\n\t\t\t\tif (typeof service.event  === 'string') data._serviceEvent  = service.event;\n\t\t\t\tif (typeof service.method === 'string') data._serviceMethod = service.method;\n\n\t\t\t}\n\n\n\t\t\tvar blob = this.__encoder(data);\n\t\t\tif (this.__isBinary === true) {\n\n\t\t\t\tvar bl    = blob.length;\n\t\t\t\tvar bytes = new Uint8Array(bl);\n\n\t\t\t\tfor (var b = 0; b < bl; b++) {\n\t\t\t\t\tbytes[b] = blob.charCodeAt(b);\n\t\t\t\t}\n\n\t\t\t\tblob = bytes.buffer;\n\n\t\t\t}\n\n\n\t\t\tthis.__socket.send(blob);\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tconnect: function() {\n\n\t\t\tif (this.__isRunning === false) {\n\t\t\t\treturn this.listen(this.port, this.host);\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tdisconnect: function() {\n\n\t\t\tif (this.__isRunning === true) {\n\n\t\t\t\tthis.__socket.close();\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetReconnect: function(reconnect) {\n\n\t\t\treconnect = typeof reconnect === 'number' ? (reconnect | 0) : null;\n\n\n\t\t\tif (reconnect !== null) {\n\n\t\t\t\tthis.reconnect = reconnect;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\taddService: function(service) {\n\n\t\t\tservice = lychee.interfaceof(lychee.net.Service, service) ? service : null;\n\n\n\t\t\tif (service !== null) {\n\n\t\t\t\tif (_is_service_waiting.call(this, service) === false && _is_service_active.call(this, service) === false) {\n\n\t\t\t\t\tthis.__services.waiting.push(service);\n\n\t\t\t\t\t// Please, Remote, plug Service! PING\n\t\t\t\t\tthis.send({}, {\n\t\t\t\t\t\tid:     service.id,\n\t\t\t\t\t\tmethod: '@plug'\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetService: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\t\t\tvar wservice = this.__services.waiting[w];\n\t\t\t\t\tif (wservice.id === id) {\n\t\t\t\t\t\treturn wservice;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\t\t\tvar aservice = this.__services.active[a];\n\t\t\t\t\tif (aservice.id === id) {\n\t\t\t\t\t\treturn aservice;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tremoveService: function(service) {\n\n\t\t\tservice = lychee.interfaceof(lychee.net.Service, service) ? service : null;\n\n\n\t\t\tif (service !== null) {\n\n\t\t\t\tif (_is_service_waiting.call(this, service) === true || _is_service_active.call(this, service) === true) {\n\n\t\t\t\t\t// Please, Remote, unplug Service! PING\n\t\t\t\t\tthis.send({}, {\n\t\t\t\t\t\tid:     service.id,\n\t\t\t\t\t\tmethod: '@unplug'\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.Logic": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Logic"
				],
				"blob": {
					"requires": [
						"lychee.game.Entity",
						"lychee.game.Layer",
						"lychee.game.Physic"
					],
					"exports": "function (lychee, global, attachments) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _project_layer = function(layer) {\n\n\t\tvar projection = this.projection;\n\t\tvar entities   = layer.entities;\n\n\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\t\t\tthis.projectPosition(entities[e].position, true);\n\t\t}\n\n\t};\n\n\tvar _unproject_layer = function(layer) {\n\n\t\tvar projection = this.projection;\n\t\tvar entities   = layer.entities;\n\n\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\t\t\tthis.unprojectPosition(entities[e].position, true);\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.physic     = null;\n\t\tthis.projection = Class.PROJECTION.pixel;\n\t\tthis.tile       = {\n\t\t\twidth:  1,\n\t\t\theight: 1,\n\t\t\tdepth:  1\n\t\t};\n\n\t\tthis.__layers   = [];\n\n\n\t\tthis.setPhysic(settings.physic);\n\t\tthis.setProjection(settings.projection);\n\t\tthis.setTile(settings.tile);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.PROJECTION = {\n\t\tpixel:    0,\n\t\ttile:     1,\n\t\tisometry: 2\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\t// TODO: Deserialize layer query paths\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.physic !== null)                       settings.physic     = this.physic;\n\t\t\tif (this.projection !== Class.PROJECTION.pixel) settings.projection = this.projection;\n\n\t\t\tif (this.tile.width !== 1 || this.tile.height !== 1 || this.tile.depth !== 1) {\n\n\t\t\t\tsettings.tile = {};\n\n\t\t\t\tif (this.tile.width !== 1)  settings.tile.width  = this.tile.width;\n\t\t\t\tif (this.tile.height !== 1) settings.tile.height = this.tile.height;\n\t\t\t\tif (this.tile.depth !== 1)  settings.tile.depth  = this.tile.depth;\n\n\t\t\t}\n\n\n\t\t\tif (this.__layers.length > 0) {\n\t\t\t\t// TODO: Serialize layers and their query paths\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Logic',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * STATE API\n\t\t */\n\n\t\tenter: function(data) {\n\n\t\t\tvar layers = this.__layers;\n\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\t\t\t\t_project_layer(layers[l]);\n\t\t\t}\n\n\t\t},\n\n\t\tleave: function(data) {\n\n\t\t\tvar layers = this.__layers;\n\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\t\t\t\t_unproject_layer(layers[l]);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar physic = this.physic;\n\t\t\tif (physic !== null) {\n\t\t\t\tphysic.update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\taddLayer: function(layer) {\n\n\t\t\tlayer = lychee.interfaceof(lychee.game.Layer, layer) ? layer : null;\n\n\n\t\t\tif (layer !== null) {\n\n\t\t\t\tvar index = this.__layers.indexOf(layer);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.__layers.push(layer);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveLayer: function(layer) {\n\n\t\t\tlayer = lychee.interfaceof(lychee.game.Layer, layer) ? layer : null;\n\n\n\t\t\tif (layer !== null) {\n\n\t\t\t\tvar index = this.__layers.indexOf(layer);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.__layers.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetLayers: function(layers) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (layers instanceof Array) {\n\n\t\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\n\t\t\t\t\tvar result = this.addLayer(layers[l]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveLayers: function() {\n\n\t\t\tvar layers = this.__layers;\n\n\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\n\t\t\t\tthis.removeLayer(layers[l]);\n\n\t\t\t\tll--;\n\t\t\t\tl--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetPhysic: function(physic) {\n\n\t\t\tphysic = lychee.interfaceof(lychee.game.Physic, physic) ? physic : null;\n\n\n\t\t\tif (physic !== null) {\n\n\t\t\t\tthis.physic = physic;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetProjection: function(projection) {\n\n\t\t\tprojection = lychee.enumof(Class.PROJECTION, projection) ? projection : null;\n\n\n\t\t\tif (projection !== null) {\n\n\t\t\t\tthis.projection = projection;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetTile: function(tile) {\n\n\t\t\tif (tile instanceof Object) {\n\n\t\t\t\tthis.tile.width  = typeof tile.width === 'number'  ? (tile.width  | 0) : this.tile.width;\n\t\t\t\tthis.tile.height = typeof tile.height === 'number' ? (tile.height | 0) : this.tile.height;\n\t\t\t\tthis.tile.depth  = typeof tile.depth === 'number'  ? (tile.depth  | 0) : this.tile.depth;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tprojectPosition: function(position, bound) {\n\n\t\t\tposition = position instanceof Object ? position : null;\n\t\t\tbound    = bound === true;\n\n\n\t\t\tif (position !== null) {\n\n\t\t\t\tvar projection = this.projection;\n\t\t\t\tvar tile       = this.tile;\n\n\t\t\t\tvar x = position.x;\n\t\t\t\tvar y = position.y;\n\t\t\t\tvar z = position.z;\n\n\n\t\t\t\tif (bound === true) {\n\n\t\t\t\t\tx |= 0;\n\t\t\t\t\ty |= 0;\n\t\t\t\t\tz |= 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (projection === Class.PROJECTION.tile) {\n\n\t\t\t\t\tx = x * tile.width;\n\t\t\t\t\ty = y * tile.height;\n\t\t\t\t\tz = z * tile.depth;\n\n\t\t\t\t} else if (projection === Class.PROJECTION.isometry) {\n\n\t\t\t\t\tx = (x - y) * tile.width;\n\t\t\t\t\ty = (x + y) * (tile.height / 2);\n\t\t\t\t\tz = 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tposition.x = x;\n\t\t\t\tposition.y = y;\n\t\t\t\tposition.z = z;\n\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tunprojectPosition: function(position, bound) {\n\n\t\t\tposition = position instanceof Object ? position : null;\n\t\t\tbound    = bound === true;\n\n\n\t\t\tif (position !== null) {\n\n\t\t\t\tvar projection = this.projection;\n\t\t\t\tvar tile       = this.tile;\n\n\t\t\t\tvar x = position.x;\n\t\t\t\tvar y = position.y;\n\t\t\t\tvar z = position.z;\n\n\n\t\t\t\tif (projection === Class.PROJECTION.tile) {\n\n\t\t\t\t\tx = x / tile.width;\n\t\t\t\t\ty = y / tile.height;\n\t\t\t\t\tz = z / tile.depth;\n\n\t\t\t\t} else if (projection === Class.PROJECTION.isometry) {\n\n\t\t\t\t\tx = (y / tile.height) + (x / (2 * tile.width));\n\t\t\t\t\ty = (y / tile.height) - (x / (2 * tile.width));\n\t\t\t\t\tz = 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (bound === true) {\n\n\t\t\t\t\tx |= 0;\n\t\t\t\t\ty |= 0;\n\t\t\t\t\tz |= 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tposition.x = x;\n\t\t\t\tposition.y = y;\n\t\t\t\tposition.z = z;\n\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.net.Service": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.net.Service"
				],
				"blob": {
					"includes": [
						"lychee.event.Emitter"
					],
					"exports": "function (lychee, global, attachments) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _services = {};\n\n\tvar _validate_tunnel = function(tunnel, type) {\n\n\t\tif (type === null) return false;\n\n\n\t\tif (type === Class.TYPE.client) {\n\t\t\treturn lychee.interfaceof(lychee.net.Client, tunnel);\n\t\t} else if (type === Class.TYPE.remote) {\n\t\t\treturn lychee.interfaceof(lychee.net.Remote, tunnel);\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _plug_broadcast = function() {\n\n\t\tvar id = this.id;\n\t\tif (id !== null) {\n\n\t\t\tvar cache = _services[id] || null;\n\t\t\tif (cache === null) {\n\t\t\t\tcache = _services[id] = [];\n\t\t\t}\n\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var c = 0, cl = cache.length; c < cl; c++) {\n\n\t\t\t\tif (cache[c] === this) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (found === false) {\n\t\t\t\tcache.push(this);\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar _unplug_broadcast = function() {\n\n\t\tthis.setMulticast([]);\n\n\n\t\tvar id = this.id;\n\t\tif (id !== null) {\n\n\t\t\tvar cache = _services[id] || null;\n\t\t\tif (cache !== null) {\n\n\t\t\t\tfor (var c = 0, cl = cache.length; c < cl; c++) {\n\n\t\t\t\t\tif (cache[c] === this) {\n\t\t\t\t\t\tcache.splice(c, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(id, tunnel, type) {\n\n\t\tid     = typeof id === 'string'          ? id     : null;\n\t\ttype   = lychee.enumof(Class.TYPE, type) ? type   : null;\n\t\ttunnel = _validate_tunnel(tunnel, type)  ? tunnel : null;\n\n\n\t\tthis.id     = id;\n\t\tthis.tunnel = tunnel;\n\t\tthis.type   = type;\n\n\t\tthis.__multicast = [];\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tif (this.id === null) {\n\t\t\t\tconsole.error('lychee.net.Service: Invalid (string) id. It has to be kept in sync with the lychee.net.Client and lychee.net.Remote instance.');\n\t\t\t}\n\n\t\t\tif (this.tunnel === null) {\n\t\t\t\tconsole.error('lychee.net.Service: Invalid (lychee.net.Client || lychee.net.Remote) tunnel.');\n\t\t\t}\n\n\t\t\tif (this.type === null) {\n\t\t\t\tconsole.error('lychee.net.Service: Invalid (lychee.net.Service.TYPE) type.');\n\t\t\t}\n\n\t\t}\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\tif (this.type === Class.TYPE.remote) {\n\n\t\t\tthis.bind('plug',   _plug_broadcast,   this);\n\t\t\tthis.bind('unplug', _unplug_broadcast, this);\n\n\t\t}\n\n\t};\n\n\n\tClass.TYPE = {\n\t\t// 'default': 0, (deactivated)\n\t\t'client': 1,\n\t\t'remote': 2\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tif (blob.tunnel instanceof Object) {\n\t\t\t\tthis.tunnel = lychee.deserialize(blob.tunnel);\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar id     = null;\n\t\t\tvar tunnel = null;\n\t\t\tvar type   = null;\n\n\t\t\tvar blob = {};\n\n\n\t\t\tif (this.id !== null)     id = this.id;\n\t\t\tif (this.tunnel !== null) blob.tunnel = lychee.serialize(this.tunnel);\n\t\t\tif (this.type !== null)   type = this.type;\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.net.Service',\n\t\t\t\t'arguments':   [ id, tunnel, type ],\n\t\t\t\t'blob':        blob\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * SERVICE API\n\t\t */\n\n\t\tmulticast: function(data, service) {\n\n\t\t\tdata    = data instanceof Object    ? data    : null;\n\t\t\tservice = service instanceof Object ? service : null;\n\n\n\t\t\tif (data === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tvar type = this.type;\n\t\t\tif (type === Class.TYPE.client) {\n\n\t\t\t\tif (service === null) {\n\n\t\t\t\t\tservice = {\n\t\t\t\t\t\tid:    this.id,\n\t\t\t\t\t\tevent: 'multicast'\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\n\t\t\t\tif (this.tunnel !== null) {\n\n\t\t\t\t\tthis.tunnel.send({\n\t\t\t\t\t\tdata:    data,\n\t\t\t\t\t\tservice: service\n\t\t\t\t\t}, {\n\t\t\t\t\t\tid:     this.id,\n\t\t\t\t\t\tmethod: 'multicast'\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else if (type === Class.TYPE.remote) {\n\n\t\t\t\tif (data.service !== null) {\n\n\t\t\t\t\tfor (var m = 0, ml = this.__multicast.length; m < ml; m++) {\n\n\t\t\t\t\t\tvar tunnel = this.__multicast[m];\n\t\t\t\t\t\tif (tunnel !== this.tunnel) {\n\n\t\t\t\t\t\t\tdata.data.tid = this.tunnel.id;\n\n\t\t\t\t\t\t\ttunnel.send(\n\t\t\t\t\t\t\t\tdata.data,\n\t\t\t\t\t\t\t\tdata.service\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tbroadcast: function(data, service) {\n\n\t\t\tdata    = data instanceof Object    ? data    : null;\n\t\t\tservice = service instanceof Object ? service : null;\n\n\n\t\t\tif (data === null || this.id === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tvar type = this.type;\n\t\t\tif (type === Class.TYPE.client) {\n\n\t\t\t\tif (service === null) {\n\n\t\t\t\t\tservice = {\n\t\t\t\t\t\tid:    this.id,\n\t\t\t\t\t\tevent: 'broadcast'\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\n\t\t\t\tif (this.tunnel !== null) {\n\n\t\t\t\t\tthis.tunnel.send({\n\t\t\t\t\t\tdata:    data,\n\t\t\t\t\t\tservice: service\n\t\t\t\t\t}, {\n\t\t\t\t\t\tid:     this.id,\n\t\t\t\t\t\tmethod: 'broadcast'\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else if (type === Class.TYPE.remote) {\n\n\t\t\t\tif (data.service !== null) {\n\n\t\t\t\t\tvar broadcast = _services[this.id] || null;\n\t\t\t\t\tif (broadcast !== null) {\n\n\t\t\t\t\t\tfor (var b = 0, bl = broadcast.length; b < bl; b++) {\n\n\t\t\t\t\t\t\tvar tunnel = broadcast[b].tunnel;\n\t\t\t\t\t\t\tif (tunnel !== this.tunnel) {\n\n\t\t\t\t\t\t\t\tdata.data.tid = this.tunnel.id;\n\n\t\t\t\t\t\t\t\ttunnel.send(\n\t\t\t\t\t\t\t\t\tdata.data,\n\t\t\t\t\t\t\t\t\tdata.service\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\treport: function(message, blob) {\n\n\t\t\tmessage = typeof message === 'string' ? message : null;\n\t\t\tblob    = blob instanceof Object      ? blob    : null;\n\n\n\t\t\tif (message !== null) {\n\n\t\t\t\tif (this.tunnel !== null) {\n\n\t\t\t\t\tthis.tunnel.send({\n\t\t\t\t\t\tmessage: message,\n\t\t\t\t\t\tblob:    blob\n\t\t\t\t\t}, {\n\t\t\t\t\t\tid:    this.id,\n\t\t\t\t\t\tevent: 'error'\n\t\t\t\t\t});\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetMulticast: function(multicast) {\n\n\t\t\tif (multicast instanceof Array) {\n\n\t\t\t\tvar valid = true;\n\t\t\t\tvar type  = this.type;\n\n\t\t\t\tfor (var m = 0, ml = multicast.length; m < ml; m++) {\n\n\t\t\t\t\tif (_validate_tunnel(multicast[m], type) === false) {\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.__multicast = multicast;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.Layer": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Layer"
				],
				"blob": {
					"requires": [
						"lychee.game.Entity"
					],
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _validate_entity = function(entity) {\n\n\t\tif (entity instanceof Object) {\n\n\t\t\tif (typeof entity.update === 'function' && typeof entity.render === 'function' && typeof entity.shape === 'number') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _SHAPE_rectangle = 2;\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.width  = 0;\n\t\tthis.height = 0;\n\n\t\tthis.effects  = [];\n\t\tthis.entities = [];\n\t\tthis.offset   = { x: 0, y: 0 };\n\t\tthis.position = { x: 0, y: 0 };\n\t\tthis.shape    = _SHAPE_rectangle;\n\t\tthis.visible  = true;\n\n\t\tthis.__map     = {};\n\t\tthis.__reshape = true;\n\n\n\t\tthis.setEntities(settings.entities);\n\t\tthis.setOffset(settings.offset);\n\t\tthis.setPosition(settings.position);\n\t\tthis.setReshape(settings.reshape);\n\t\tthis.setVisible(settings.visible);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tvar entities = [];\n\t\t\tfor (var be = 0, bel = blob.entities.length; be < bel; be++) {\n\t\t\t\tentities.push(lychee.deserialize(blob.entities[be]));\n\t\t\t}\n\n\t\t\tvar map = {};\n\t\t\tfor (var bid in blob.map) {\n\n\t\t\t\tvar index = blob.map[bid];\n\t\t\t\tif (typeof index === 'number') {\n\t\t\t\t\tmap[bid] = index;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tvar id = null;\n\t\t\t\tfor (var mid in map) {\n\n\t\t\t\t\tif (map[mid] === e) {\n\t\t\t\t\t\tid = mid;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (id !== null) {\n\t\t\t\t\tthis.setEntity(id, entities[e]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.addEntity(entities[e]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.offset.x !== 0 || this.offset.y !== 0 || this.offset.z !== 0) {\n\n\t\t\t\tsettings.offset = {};\n\n\t\t\t\tif (this.offset.x !== 0) settings.offset.x = this.offset.x;\n\t\t\t\tif (this.offset.y !== 0) settings.offset.y = this.offset.y;\n\t\t\t\tif (this.offset.z !== 0) settings.offset.z = this.offset.z;\n\n\t\t\t}\n\n\t\t\tif (this.__reshape !== true) settings.reshape = this.__reshape;\n\t\t\tif (this.visible !== true)   settings.visible = this.visible;\n\n\n\t\t\tvar entities = [];\n\n\t\t\tif (this.entities.length > 0) {\n\n\t\t\t\tblob.entities = [];\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\n\t\t\t\t\tblob.entities.push(lychee.serialize(entity));\n\t\t\t\t\tentities.push(entity);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (Object.keys(this.__map).length > 0) {\n\n\t\t\t\tblob.map = {};\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tvar index = entities.indexOf(this.__map[id]);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tblob.map[id] = index;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Layer',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\t\trender: function(renderer, offsetX, offsetY) {\n\n\t\t\tif (this.visible === false) return;\n\n\t\t\tvar position = this.position;\n\t\t\tvar offset   = this.offset;\n\n\n\t\t\tvar ox = position.x + offsetX + offset.x;\n\t\t\tvar oy = position.y + offsetY + offset.y;\n\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tentities[e].render(\n\t\t\t\t\trenderer,\n\t\t\t\t\tox,\n\t\t\t\t\toy\n\t\t\t\t);\n\n\t\t\t}\n\n\n\t\t\tif (lychee.debug === true) {\n\n\t\t\t\tox = position.x + offsetX;\n\t\t\t\toy = position.y + offsetY;\n\n\n\t\t\t\tvar hwidth   = this.width  / 2;\n\t\t\t\tvar hheight  = this.height / 2;\n\n\n\t\t\t\trenderer.drawBox(\n\t\t\t\t\tox - hwidth,\n\t\t\t\t\toy - hheight,\n\t\t\t\t\tox + hwidth,\n\t\t\t\t\toy + hheight,\n\t\t\t\t\t'#ffff00',\n\t\t\t\t\tfalse,\n\t\t\t\t\t1\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var en = 0, enl = entities.length; en < enl; en++) {\n\t\t\t\tentities[en].update(clock, delta);\n\t\t\t}\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var ef = 0, efl = this.effects.length; ef < efl; ef++) {\n\n\t\t\t\tvar effect = this.effects[ef];\n\t\t\t\tif (effect.update(this, clock, delta) === false) {\n\t\t\t\t\tthis.removeEffect(effect);\n\t\t\t\t\tefl--;\n\t\t\t\t\tef--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\treshape: function() {\n\n\t\t\tif (this.__reshape === true) {\n\n\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\tvar hheight = this.height / 2;\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\tvar boundx = Math.abs(entity.position.x + this.offset.x);\n\t\t\t\t\tvar boundy = Math.abs(entity.position.y + this.offset.y);\n\n\t\t\t\t\tif (entity.shape === lychee.game.Entity.SHAPE.circle) {\n\t\t\t\t\t\tboundx += entity.radius;\n\t\t\t\t\t\tboundy += entity.radius;\n\t\t\t\t\t} else if (entity.shape === lychee.game.Entity.SHAPE.rectangle) {\n\t\t\t\t\t\tboundx += entity.width  / 2;\n\t\t\t\t\t\tboundy += entity.height / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\thwidth  = Math.max(hwidth,  boundx);\n\t\t\t\t\thheight = Math.max(hheight, boundy);\n\n\t\t\t\t}\n\n\t\t\t\tthis.width  = hwidth  * 2;\n\t\t\t\tthis.height = hheight * 2;\n\n\t\t\t}\n\n\t\t},\n\n\t\taddEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.effects.push(effect);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.effects.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffects: function() {\n\n\t\t\tvar effects = this.effects;\n\n\t\t\tfor (var e = 0, el = effects.length; e < el; e++) {\n\n\t\t\t\teffects[e].update(this, Infinity, 0);\n\t\t\t\tthis.removeEffect(effects[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\taddEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar index = this.entities.indexOf(entity);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.entities.push(entity);\n\t\t\t\t\tthis.reshape();\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntity: function(id, entity) {\n\n\t\t\tid     = typeof id === 'string'            ? id     : null;\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (id !== null && entity !== null && this.__map[id] === undefined) {\n\n\t\t\t\tthis.__map[id] = entity;\n\n\t\t\t\tvar result = this.addEntity(entity);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetEntity: function(id, position) {\n\n\t\t\tid        = typeof id === 'string'    ? id       : null;\n\t\t\tposition = position instanceof Object ? position : null;\n\n\n\t\t\tvar found = null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tif (this.__map[id] !== undefined) {\n\t\t\t\t\tfound = this.__map[id];\n\t\t\t\t}\n\n\t\t\t} else if (position !== null) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tfor (var e = this.entities.length - 1; e >= 0; e--) {\n\n\t\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\t\tif (entity.isAtPosition(position) === true) {\n\t\t\t\t\t\t\tfound = entity;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\t\tremoveEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar found = false;\n\n\t\t\t\tvar index = this.entities.indexOf(entity);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.entities.splice(index, 1);\n\t\t\t\t\tfound = true;\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tif (this.__map[id] === entity) {\n\n\t\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t\t\tfound = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (found === true) {\n\t\t\t\t\tthis.reshape();\n\t\t\t\t}\n\n\n\t\t\t\treturn found;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntities: function(entities) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (entities instanceof Array) {\n\n\t\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\t\tvar result = this.addEntity(entities[e]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveEntities: function() {\n\n\t\t\tvar entities = this.entities;\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tthis.removeEntity(entities[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetOffset: function(offset) {\n\n\t\t\tif (offset instanceof Object) {\n\n\t\t\t\tthis.offset.x = typeof offset.x === 'number' ? offset.x : this.offset.x;\n\t\t\t\tthis.offset.y = typeof offset.y === 'number' ? offset.y : this.offset.y;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tthis.position.x = typeof position.x === 'number' ? position.x : this.position.x;\n\t\t\t\tthis.position.y = typeof position.y === 'number' ? position.y : this.position.y;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetReshape: function(reshape) {\n\n\t\t\tif (reshape === true || reshape === false) {\n\n\t\t\t\tthis.__reshape = reshape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVisible: function(visible) {\n\n\t\t\tif (visible === true || visible === false) {\n\n\t\t\t\tthis.visible = visible;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.ui.Layer": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.ui.Layer"
				],
				"blob": {
					"includes": [
						"lychee.ui.Entity"
					],
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _validate_entity = function(entity) {\n\n\t\tif (entity instanceof Object) {\n\n\t\t\tif (typeof entity.update === 'function' && typeof entity.render === 'function' && typeof entity.shape === 'number') {\n\n\t\t\t\tif (typeof entity.isAtPosition === 'function') {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _process_touch = function(id, position, delta) {\n\n\t\tvar triggered = null;\n\t\tvar args      = [ id, {\n\t\t\tx: position.x - this.offset.x,\n\t\t\ty: position.y - this.offset.y\n\t\t}, delta ];\n\n\n\t\tvar entity = this.getEntity(null, args[1]);\n\t\tif (entity !== null) {\n\n\t\t\tif (typeof entity.trigger === 'function') {\n\n\t\t\t\targs[1].x -= entity.position.x;\n\t\t\t\targs[1].y -= entity.position.y;\n\n\t\t\t\tvar result = entity.trigger('touch', args);\n\t\t\t\tif (result === true) {\n\t\t\t\t\ttriggered = entity;\n\t\t\t\t} else if (result !== false) {\n\t\t\t\t\ttriggered = result;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn triggered;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.entities = [];\n\t\tthis.offset   = { x: 0, y: 0 };\n\t\tthis.visible  = true;\n\n\t\tthis.__map     = {};\n\t\tthis.__reshape = true;\n\n\n\t\tthis.setEntities(settings.entities);\n\t\tthis.setOffset(settings.offset);\n\t\tthis.setReshape(settings.reshape);\n\t\tthis.setVisible(settings.visible);\n\n\t\tdelete settings.entities;\n\t\tdelete settings.offset;\n\t\tdelete settings.reshape;\n\t\tdelete settings.visible;\n\n\n\t\tsettings.shape = lychee.ui.Entity.SHAPE.rectangle;\n\n\n\t\tlychee.ui.Entity.call(this, settings);\n\n\t\tsettings = null;\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\tthis.bind('touch', _process_touch, this);\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tvar entities = [];\n\t\t\tfor (var be = 0, bel = blob.entities.length; be < bel; be++) {\n\t\t\t\tentities.push(lychee.deserialize(blob.entities[be]));\n\t\t\t}\n\n\t\t\tvar map = {};\n\t\t\tfor (var bid in blob.map) {\n\n\t\t\t\tvar index = blob.map[bid];\n\t\t\t\tif (typeof index === 'number') {\n\t\t\t\t\tmap[bid] = index;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tvar id = null;\n\t\t\t\tfor (var mid in map) {\n\n\t\t\t\t\tif (map[mid] === e) {\n\t\t\t\t\t\tid = mid;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (id !== null) {\n\t\t\t\t\tthis.setEntity(id, entities[e]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.addEntity(entities[e]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar data = lychee.ui.Entity.prototype.serialize.call(this);\n\t\t\tdata['constructor'] = 'lychee.ui.Layer';\n\n\t\t\tvar settings = data['arguments'][0];\n\t\t\tvar blob     = data['blob'] = (data['blob'] || {});\n\n\n\t\t\tif (this.offset.x !== 0 || this.offset.y !== 0) {\n\n\t\t\t\tsettings.offset = {};\n\n\t\t\t\tif (this.offset.x !== 0) settings.offset.x = this.offset.x;\n\t\t\t\tif (this.offset.y !== 0) settings.offset.y = this.offset.y;\n\n\t\t\t}\n\n\t\t\tif (this.__reshape !== true) settings.reshape = this.__reshape;\n\t\t\tif (this.visible !== true)   settings.visible = this.visible;\n\n\n\t\t\tvar entities = [];\n\n\t\t\tif (this.entities.length > 0) {\n\n\t\t\t\tblob.entities = [];\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\n\t\t\t\t\tblob.entities.push(lychee.serialize(entity));\n\t\t\t\t\tentities.push(entity);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (Object.keys(this.__map).length > 0) {\n\n\t\t\t\tblob.map = {};\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tvar index = entities.indexOf(this.__map[id]);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tblob.map[id] = index;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tdata.blob = Object.keys(data.blob).length > 0 ? data.blob : null;\n\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tlychee.ui.Entity.prototype.update.call(this, clock, delta);\n\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\t\t\t\tentities[e].update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\t\trender: function(renderer, offsetX, offsetY) {\n\n\t\t\tif (this.visible === false) return;\n\n\n\t\t\tvar position = this.position;\n\t\t\tvar offset   = this.offset;\n\n\n\t\t\tvar ox = position.x + offsetX + offset.x;\n\t\t\tvar oy = position.y + offsetY + offset.y;\n\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tentities[e].render(\n\t\t\t\t\trenderer,\n\t\t\t\t\tox,\n\t\t\t\t\toy\n\t\t\t\t);\n\n\t\t\t}\n\n\n\t\t\tif (lychee.debug === true) {\n\n\t\t\t\tox = position.x + offsetX;\n\t\t\t\toy = position.y + offsetY;\n\n\n\t\t\t\tvar hwidth   = this.width  / 2;\n\t\t\t\tvar hheight  = this.height / 2;\n\n\n\t\t\t\trenderer.drawBox(\n\t\t\t\t\tox - hwidth,\n\t\t\t\t\toy - hheight,\n\t\t\t\t\tox + hwidth,\n\t\t\t\t\toy + hheight,\n\t\t\t\t\t'#ff00ff',\n\t\t\t\t\tfalse,\n\t\t\t\t\t1\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\treshape: function() {\n\n\t\t\tif (this.__reshape === true) {\n\n\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\tvar hheight = this.height / 2;\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\tif (typeof entity.reshape === 'function') {\n\t\t\t\t\t\tentity.reshape();\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar boundx = Math.abs(entity.position.x + this.offset.x);\n\t\t\t\t\tvar boundy = Math.abs(entity.position.y + this.offset.y);\n\n\t\t\t\t\tif (entity.shape === lychee.ui.Entity.SHAPE.circle) {\n\t\t\t\t\t\tboundx += entity.radius;\n\t\t\t\t\t\tboundy += entity.radius;\n\t\t\t\t\t} else if (entity.shape === lychee.ui.Entity.SHAPE.rectangle) {\n\t\t\t\t\t\tboundx += entity.width  / 2;\n\t\t\t\t\t\tboundy += entity.height / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\thwidth  = Math.max(hwidth,  boundx);\n\t\t\t\t\thheight = Math.max(hheight, boundy);\n\n\t\t\t\t}\n\n\t\t\t\tthis.width  = hwidth  * 2;\n\t\t\t\tthis.height = hheight * 2;\n\n\t\t\t}\n\n\t\t},\n\n\t\taddEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar index = this.entities.indexOf(entity);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.entities.push(entity);\n\t\t\t\t\tthis.reshape();\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntity: function(id, entity) {\n\n\t\t\tid     = typeof id === 'string'            ? id     : null;\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (id !== null && entity !== null && this.__map[id] === undefined) {\n\n\t\t\t\tthis.__map[id] = entity;\n\n\t\t\t\tvar result = this.addEntity(entity);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetEntity: function(id, position) {\n\n\t\t\tid        = typeof id === 'string'    ? id       : null;\n\t\t\tposition = position instanceof Object ? position : null;\n\n\n\t\t\tvar found = null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tif (this.__map[id] !== undefined) {\n\t\t\t\t\tfound = this.__map[id];\n\t\t\t\t}\n\n\t\t\t} else if (position !== null) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tfor (var e = this.entities.length - 1; e >= 0; e--) {\n\n\t\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\t\tif (entity.visible === false) continue;\n\n\t\t\t\t\t\tif (entity.isAtPosition(position) === true) {\n\t\t\t\t\t\t\tfound = entity;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\t\tremoveEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar found = false;\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tif (this.entities[e] === entity) {\n\t\t\t\t\t\tthis.entities.splice(e, 1);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tel--;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tif (this.__map[id] === entity) {\n\t\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (found === true) {\n\t\t\t\t\tthis.reshape();\n\t\t\t\t}\n\n\n\t\t\t\treturn found;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntities: function(entities) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (entities instanceof Array) {\n\n\t\t\t\tthis.entities = [];\n\n\t\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\t\tvar result = this.addEntity(entities[e]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveEntities: function() {\n\n\t\t\tvar entities = this.entities;\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tthis.removeEntity(entities[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetOffset: function(offset) {\n\n\t\t\tif (offset instanceof Object) {\n\n\t\t\t\tthis.offset.x = typeof offset.x === 'number' ? offset.x : this.offset.x;\n\t\t\t\tthis.offset.y = typeof offset.y === 'number' ? offset.y : this.offset.y;\n\n\t\t\t\tthis.reshape();\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetReshape: function(reshape) {\n\n\t\t\tif (reshape === true || reshape === false) {\n\n\t\t\t\tthis.__reshape = reshape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVisible: function(visible) {\n\n\t\t\tif (visible === true || visible === false) {\n\n\t\t\t\tthis.visible = visible;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.Physic": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Physic"
				],
				"blob": {
					"exports": "function (lychee, global, attachments) {\n\n\tvar Class = function(data) {\n\t};\n\n\n\tClass.prototype = {\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.ui.Entity": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.ui.Entity"
				],
				"blob": {
					"includes": [
						"lychee.event.Emitter"
					],
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _default_state  = 'default';\n\tvar _default_states = { 'default': null, 'active': null };\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.width  = typeof settings.width  === 'number' ? settings.width  : 0;\n\t\tthis.height = typeof settings.height === 'number' ? settings.height : 0;\n\t\tthis.depth  = 0;\n\t\tthis.radius = typeof settings.radius === 'number' ? settings.radius : 0;\n\n\t\tthis.alpha     = 1;\n\t\tthis.collision = 1; // Used for event flow, NOT modifiable\n\t\tthis.effects   = [];\n\t\tthis.shape     = Class.SHAPE.rectangle;\n\t\tthis.state     = _default_state;\n\t\tthis.position  = { x: 0, y: 0 };\n\t\tthis.visible   = true;\n\n\t\tthis.__states  = _default_states;\n\n\n\t\tif (settings.states instanceof Object) {\n\n\t\t\tthis.__states = { 'default': null, 'active': null };\n\n\t\t\tfor (var id in settings.states) {\n\n\t\t\t\tif (settings.states.hasOwnProperty(id)) {\n\t\t\t\t\tthis.__states[id] = settings.states[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.setAlpha(settings.alpha);\n\t\tthis.setShape(settings.shape);\n\t\tthis.setState(settings.state);\n\t\tthis.setPosition(settings.position);\n\t\tthis.setVisible(settings.visible);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\t// Same ENUM values as lychee.game.Entity\n\tClass.SHAPE = {\n\t\tcircle:    0,\n\t\trectangle: 2\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) { },\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.width  !== 0) settings.width  = this.width;\n\t\t\tif (this.height !== 0) settings.height = this.height;\n\t\t\tif (this.radius !== 0) settings.radius = this.radius;\n\n\t\t\tif (this.alpha !== 1)                     settings.alpha   = this.alpha;\n\t\t\tif (this.shape !== Class.SHAPE.rectangle) settings.shape   = this.shape;\n\t\t\tif (this.state !== _default_state)        settings.state   = this.state;\n\t\t\tif (this.__states !== _default_states)    settings.states  = this.__states;\n\t\t\tif (this.visible !== true)                settings.visible = this.visible;\n\n\n\t\t\tif (this.position.x !== 0 || this.position.y !== 0) {\n\n\t\t\t\tsettings.position = {};\n\n\t\t\t\tif (this.position.x !== 0) settings.position.x = this.position.x;\n\t\t\t\tif (this.position.y !== 0) settings.position.y = this.position.y;\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.ui.Entity',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        null\n\t\t\t};\n\n\t\t},\n\n\t\t// HINT: Renderer skips if no render() method exists\n\t\t// render: function(renderer, offsetX, offsetY) {},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var e = 0, el = this.effects.length; e < el; e++) {\n\n\t\t\t\tvar effect = this.effects[e];\n\t\t\t\tif (effect.update(this, clock, delta) === false) {\n\t\t\t\t\tthis.removeEffect(effect);\n\t\t\t\t\tel--;\n\t\t\t\t\te--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tisAtPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tvar ax = position.x;\n\t\t\t\t\tvar ay = position.y;\n\t\t\t\t\tvar bx = this.position.x;\n\t\t\t\t\tvar by = this.position.y;\n\n\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tif (shape === Class.SHAPE.circle) {\n\n\t\t\t\t\t\tvar dist = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\t\t\t\t\t\tif (dist < this.radius) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (shape === Class.SHAPE.rectangle) {\n\n\t\t\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\t\t\tvar hheight = this.height / 2;\n\t\t\t\t\t\tvar colX    = (ax >= bx - hwidth)  && (ax <= bx + hwidth);\n\t\t\t\t\t\tvar colY    = (ay >= by - hheight) && (ay <= by + hheight);\n\n\n\t\t\t\t\t\treturn colX && colY;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\n\t\t\talpha = (typeof alpha === 'number' && alpha >= 0 && alpha <= 1) ? alpha : null;\n\n\n\t\t\tif (alpha !== null) {\n\n\t\t\t\tthis.alpha = alpha;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\taddEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.effects.push(effect);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.effects.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffects: function() {\n\n\t\t\tvar effects = this.effects;\n\n\t\t\tfor (var e = 0, el = effects.length; e < el; e++) {\n\n\t\t\t\teffects[e].update(this, Infinity, 0);\n\t\t\t\tthis.removeEffect(effects[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tthis.position.x = typeof position.x === 'number' ? position.x : this.position.x;\n\t\t\t\tthis.position.y = typeof position.y === 'number' ? position.y : this.position.y;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetShape: function(shape) {\n\n\t\t\tif (lychee.enumof(Class.SHAPE, shape)) {\n\n\t\t\t\tthis.shape = shape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetStateMap: function() {\n\t\t\treturn this.__states[this.state];\n\t\t},\n\n\t\tsetState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__states[id] !== undefined) {\n\n\t\t\t\tthis.state = id;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVisible: function(visible) {\n\n\t\t\tif (visible === true || visible === false) {\n\n\t\t\t\tthis.visible = visible;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			},
			"lychee.game.Entity": {
				"constructor": "lychee.Definition",
				"arguments": [
					"lychee.game.Entity"
				],
				"blob": {
					"exports": "function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _sphere_sphere = function(a, b) {\n\n\t\tvar dx  = Math.sqrt(Math.pow(b.position.x - a.position.x, 2));\n\t\tvar dy  = Math.sqrt(Math.pow(b.position.y - a.position.y, 2));\n\t\tvar dz  = Math.sqrt(Math.pow(b.position.z - a.position.z, 2));\n\n\t\tvar rxy = 0;\n\t\tvar rxz = 0;\n\n\t\tif (a.shape === Class.SHAPE.sphere) {\n\t\t\trxy += a.radius;\n\t\t\trxz += a.radius;\n\t\t}\n\n\t\tif (b.shape === Class.SHAPE.sphere) {\n\t\t\trxy += b.radius;\n\t\t\trxz += b.radius;\n\t\t}\n\n\t\treturn ((dx + dy) <= rxy && (dx + dz) <= rxz);\n\n\t};\n\n\tvar _sphere_cuboid = function(a, b) {\n\n\t\tvar r  = a.radius;\n\t\tvar hw = b.width  / 2;\n\t\tvar hh = b.height / 2;\n\t\tvar hd = b.depth  / 2;\n\n\t\tvar ax = a.position.x;\n\t\tvar ay = a.position.y;\n\t\tvar az = a.position.z;\n\n\t\tvar bx = b.position.x;\n\t\tvar by = b.position.y;\n\t\tvar bz = b.position.z;\n\n\t\tvar colx = (ax + r >= bx - hw) && (ax - r <= bx + hw);\n\t\tvar coly = (ay + r >= by - hh) && (ay - r <= by + hh);\n\n\t\tif (a.shape === Class.SHAPE.circle) {\n\t\t\tr = 0;\n\t\t}\n\n\t\tvar colz = (az + r >= bz - hd) && (az - r <= bz + hd);\n\n\t\treturn (colx && coly && colz);\n\n\t};\n\n\tvar _cuboid_cuboid = function(a, b) {\n\n\t\tvar dx = Math.abs(b.position.x - a.position.x);\n\t\tvar dy = Math.abs(b.position.y - a.position.y);\n\t\tvar dz = Math.abs(b.position.z - a.position.z);\n\n\t\tvar hw = (a.width  + b.width)  / 2;\n\t\tvar hh = (a.height + b.height) / 2;\n\t\tvar hd = (a.depth  + b.depth)  / 2;\n\n\t\treturn (dx <= hw && dy <= hh && dz <= hd);\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _default_state  = 'default';\n\tvar _default_states = { 'default': null };\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.width  = typeof settings.width  === 'number' ? settings.width  : 0;\n\t\tthis.height = typeof settings.height === 'number' ? settings.height : 0;\n\t\tthis.depth  = typeof settings.depth  === 'number' ? settings.depth  : 0;\n\t\tthis.radius = typeof settings.radius === 'number' ? settings.radius : 0;\n\n\t\tthis.alpha     = 1;\n\t\tthis.collision = Class.COLLISION.none;\n\t\tthis.effects   = [];\n\t\tthis.shape     = Class.SHAPE.rectangle;\n\t\tthis.state     = _default_state;\n\t\tthis.position  = { x: 0, y: 0, z: 0 };\n\t\tthis.velocity  = { x: 0, y: 0, z: 0 };\n\n\t\tthis.__states  = _default_states;\n\n\n\t\tif (settings.states instanceof Object) {\n\n\t\t\tthis.__states = { 'default': null };\n\n\t\t\tfor (var id in settings.states) {\n\n\t\t\t\tif (settings.states.hasOwnProperty(id)) {\n\t\t\t\t\tthis.__states[id] = settings.states[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.setAlpha(settings.alpha);\n\t\tthis.setCollision(settings.collision);\n\t\tthis.setShape(settings.shape);\n\t\tthis.setState(settings.state);\n\t\tthis.setPosition(settings.position);\n\t\tthis.setVelocity(settings.velocity);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.COLLISION = {\n\t\tnone: 0,\n\t\tA:    1,\n\t\tB:    2,\n\t\tC:    3,\n\t\tD:    4\n\t};\n\n\n\t// Same ENUM values as lychee.ui.Entity\n\tClass.SHAPE = {\n\t\tcircle:    0,\n\t\trectangle: 1,\n\t\tsphere:    2,\n\t\tcuboid:    3\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.width  !== 0) settings.width  = this.width;\n\t\t\tif (this.height !== 0) settings.height = this.height;\n\t\t\tif (this.depth  !== 0) settings.depth  = this.depth;\n\t\t\tif (this.radius !== 0) settings.radius = this.radius;\n\n\t\t\tif (this.alpha !== 1)                         settings.alpha     = this.alpha;\n\t\t\tif (this.collision !== Class.COLLISION.none)  settings.collision = this.collision;\n\t\t\tif (this.shape !== Class.SHAPE.rectangle)     settings.shape     = this.shape;\n\t\t\tif (this.state !== _default_state)            settings.state     = this.state;\n\t\t\tif (this.__states !== _default_states)        settings.states    = this.__states;\n\n\n\t\t\tif (this.position.x !== 0 || this.position.y !== 0 || this.position.z !== 0) {\n\n\t\t\t\tsettings.position = {};\n\n\t\t\t\tif (this.position.x !== 0) settings.position.x = this.position.x;\n\t\t\t\tif (this.position.y !== 0) settings.position.y = this.position.y;\n\t\t\t\tif (this.position.z !== 0) settings.position.z = this.position.z;\n\n\t\t\t}\n\n\n\t\t\tif (this.velocity.x !== 0 || this.velocity.y !== 0 || this.velocity.z !== 0) {\n\n\t\t\t\tsettings.velocity = {};\n\n\t\t\t\tif (this.velocity.x !== 0) settings.velocity.x = this.velocity.x;\n\t\t\t\tif (this.velocity.y !== 0) settings.velocity.y = this.velocity.y;\n\t\t\t\tif (this.velocity.z !== 0) settings.velocity.z = this.velocity.z;\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Entity',\n\t\t\t\t'arguments':   [ settings ]\n\t\t\t};\n\n\t\t},\n\n\t\t// HINT: Renderer skips if no render() method exists\n\t\trender: function(renderer, offsetX, offsetY) {\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var e = 0, el = this.effects.length; e < el; e++) {\n\t\t\t\tthis.effects[e].render(renderer, offsetX, offsetY);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar velocity = this.velocity;\n\n\t\t\tif (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n\n\t\t\t\tvar x = this.position.x;\n\t\t\t\tvar y = this.position.y;\n\t\t\t\tvar z = this.position.z;\n\n\n\t\t\t\tvar vt = delta / 1000;\n\n\t\t\t\tif (velocity.x !== 0) {\n\t\t\t\t\tx += velocity.x * vt;\n\t\t\t\t}\n\n\t\t\t\tif (velocity.y !== 0) {\n\t\t\t\t\ty += velocity.y * vt;\n\t\t\t\t}\n\n\t\t\t\tif (velocity.z !== 0) {\n\t\t\t\t\tz += velocity.z * vt;\n\t\t\t\t}\n\n\n\t\t\t\tthis.position.x = x;\n\t\t\t\tthis.position.y = y;\n\t\t\t\tthis.position.z = z;\n\n\t\t\t}\n\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var e = 0, el = this.effects.length; e < el; e++) {\n\n\t\t\t\tvar effect = this.effects[e];\n\t\t\t\tif (effect.update(this, clock, delta) === false) {\n\t\t\t\t\tthis.removeEffect(effect);\n\t\t\t\t\tel--;\n\t\t\t\t\te--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tisAtPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tvar ax = position.x;\n\t\t\t\t\tvar ay = position.y;\n\t\t\t\t\tvar bx = this.position.x;\n\t\t\t\t\tvar by = this.position.y;\n\n\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tif (shape === Class.SHAPE.circle) {\n\n\t\t\t\t\t\tvar dist = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\t\t\t\t\t\tif (dist < this.radius) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (shape === Class.SHAPE.rectangle) {\n\n\t\t\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\t\t\tvar hheight = this.height / 2;\n\t\t\t\t\t\tvar colX    = (ax >= bx - hwidth)  && (ax <= bx + hwidth);\n\t\t\t\t\t\tvar colY    = (ay >= by - hheight) && (ay <= by + hheight);\n\n\n\t\t\t\t\t\treturn colX && colY;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tcollidesWith: function(entity) {\n\n\t\t\tvar none = Class.COLLISION.none;\n\t\t\tif (this.collision !== entity.collision || this.collision === none || entity.collision === none) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tvar circle    = Class.SHAPE.circle;\n\t\t\tvar sphere    = Class.SHAPE.sphere;\n\t\t\tvar rectangle = Class.SHAPE.rectangle;\n\t\t\tvar cuboid    = Class.SHAPE.cuboid;\n\n\t\t\tvar shapeA    = this.shape;\n\t\t\tvar shapeB    = entity.shape;\n\n\t\t\tvar issphereA = shapeA === circle    || shapeA === sphere;\n\t\t\tvar issphereB = shapeB === circle    || shapeB === sphere;\n\t\t\tvar iscuboidA = shapeA === rectangle || shapeA === cuboid;\n\t\t\tvar iscuboidB = shapeB === rectangle || shapeB === cuboid;\n\n\t\t\tif (issphereA && issphereB) {\n\t\t\t\treturn _sphere_sphere(this, entity);\n\t\t\t} else if (iscuboidA && iscuboidB) {\n\t\t\t\treturn _cuboid_cuboid(this, entity);\n\t\t\t} else if (issphereA && iscuboidB) {\n\t\t\t\treturn _sphere_cuboid(this, entity);\n\t\t\t} else if (iscuboidA && issphereB) {\n\t\t\t\treturn _sphere_cuboid(entity, this);\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\n\t\t\talpha = (typeof alpha === 'number' && alpha >= 0 && alpha <= 1) ? alpha : null;\n\n\n\t\t\tif (alpha !== null) {\n\n\t\t\t\tthis.alpha = alpha;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetCollision: function(collision) {\n\n\t\t\tif (lychee.enumof(Class.COLLISION, collision)) {\n\n\t\t\t\tthis.collision = collision;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\taddEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.effects.push(effect);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.effects.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffects: function() {\n\n\t\t\tvar effects = this.effects;\n\n\t\t\tfor (var e = 0, el = effects.length; e < el; e++) {\n\n\t\t\t\teffects[e].update(this, Infinity, 0);\n\t\t\t\tthis.removeEffect(effects[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetPosition: function(position) {\n\n\t\t\tposition = position instanceof Object ? position : null;\n\n\n\t\t\tif (position !== null) {\n\n\t\t\t\tthis.position.x = typeof position.x === 'number' ? position.x : this.position.x;\n\t\t\t\tthis.position.y = typeof position.y === 'number' ? position.y : this.position.y;\n\t\t\t\tthis.position.z = typeof position.z === 'number' ? position.z : this.position.z;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetShape: function(shape) {\n\n\t\t\tif (lychee.enumof(Class.SHAPE, shape)) {\n\n\t\t\t\tthis.shape = shape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetStateMap: function() {\n\t\t\treturn this.__states[this.state];\n\t\t},\n\n\t\tsetState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__states[id] !== undefined) {\n\n\t\t\t\tthis.state = id;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVelocity: function(velocity) {\n\n\t\t\tvelocity = velocity instanceof Object ? velocity : null;\n\n\n\t\t\tif (velocity !== null) {\n\n\t\t\t\tthis.velocity.x = typeof velocity.x === 'number' ? velocity.x : this.velocity.x;\n\t\t\t\tthis.velocity.y = typeof velocity.y === 'number' ? velocity.y : this.velocity.y;\n\t\t\t\tthis.velocity.z = typeof velocity.z === 'number' ? velocity.z : this.velocity.z;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"
				}
			}
		},
		"type": "build",
		"build": "lychee.game.Main"
	}
});

	if (environment !== null) {
		environment.init();
	}

	lychee.ENVIRONMENTS['lychee/html/main'] = environment;

})(lychee, typeof global !== 'undefined' ? global : this);

