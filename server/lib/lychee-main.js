
/*
 * lycheeJS 0.8
 * 
 * {"platform":["nodejs"]}
 * 
 * lychee.Input
 * lychee.Renderer
 * lychee.Storage
 * lychee.Viewport
 * lychee.event.Emitter
 * lychee.game.Entity
 * lychee.game.Jukebox
 * lychee.game.Layer
 * lychee.game.Logic
 * lychee.game.Loop
 * lychee.game.Main
 * lychee.game.Physic
 * lychee.game.State
 * lychee.net.Client
 * lychee.ui.Entity
 * lychee.ui.Layer
 */


(function(lychee, global) {

	var environment = lychee.deserialize({"constructor":"lychee.Environment","arguments":[{"id":"lychee/nodejs/main","build":"lychee.game.Main","debug":false,"sandbox":false,"type":"build","tags":{"platform":["nodejs"]}}],"blob":{"definitions":{"lychee.game.Main":{"constructor":"lychee.Definition","arguments":["lychee.game.Main"],"blob":{"requires":["lychee.Input","lychee.Renderer","lychee.Storage","lychee.Viewport","lychee.game.Jukebox","lychee.game.Loop","lychee.game.State","lychee.net.Client"],"includes":["lychee.event.Emitter"],"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _load_client = function(url) {\n\n\t\turl = typeof url === 'string' ? url : '/api/Server?identifier=boilerplate';\n\n\n\t\tvar asset = lychee.Environment.createAsset(url, 'json');\n\t\tif (asset !== null) {\n\n\t\t\tvar that = this;\n\n\t\t\tasset.onload = function(result) {\n\n\t\t\t\tif (result === true) {\n\t\t\t\t\tthat.settings.client = lychee.extend({}, this.buffer);\n\t\t\t\t}\n\n\t\t\t\t_initialize.call(that);\n\n\t\t\t};\n\n\t\t\tasset.load();\n\n\t\t}\n\n\t};\n\n\tvar _load_server = function(url) {\n\n\t\t// TODO: Server or Router initialization\n\n\t};\n\n\tvar _initialize = function() {\n\n\t\tthis.trigger('load', []);\n\n\n\t\tvar settings = this.settings;\n\n\t\tif (settings.client !== null) {\n\n\t\t\tthis.client = new lychee.net.Client(settings.client);\n\n\n\t\t\tvar port = settings.client.port || null;\n\t\t\tvar host = settings.client.host || null;\n\t\t\tif (port !== null && host !== null) {\n\t\t\t\tthis.client.listen(port, host);\n\t\t\t}\n\n\t\t}\n\n\t\tif (settings.input !== null) {\n\t\t\tthis.input = new lychee.Input(settings.input);\n\t\t}\n\n\t\tif (settings.jukebox !== null) {\n\t\t\tthis.jukebox = new lychee.game.Jukebox(settings.jukebox);\n\t\t}\n\n\t\tif (settings.loop !== null) {\n\t\t\tthis.loop = new lychee.game.Loop(settings.loop);\n\t\t\tthis.loop.bind('render', this.render, this);\n\t\t\tthis.loop.bind('update', this.update, this);\n\t\t}\n\n\t\tif (settings.renderer !== null) {\n\t\t\tthis.renderer = new lychee.Renderer(settings.renderer);\n\t\t}\n\n\t\tif (settings.viewport !== null) {\n\n\t\t\tthis.viewport = new lychee.Viewport();\n\t\t\tthis.viewport.bind('reshape', this.reshape, this);\n\t\t\tthis.viewport.bind('hide',    this.hide,    this);\n\t\t\tthis.viewport.bind('show',    this.show,    this);\n\n\t\t\tthis.viewport.setFullscreen(settings.viewport.fullscreen);\n\n\t\t}\n\n\n\t\tthis.trigger('init', []);\n\n\t};\n\n\n\n\t/*\n\t * DEFAULT SETTINGS\n\t * and SERIALIZATION CACHE\n\t */\n\n\tvar _defaults = {\n\n\t\tinput: {\n\t\t\tdelay:       0,\n\t\t\tkey:         false,\n\t\t\tkeymodifier: false,\n\t\t\ttouch:       true,\n\t\t\tswipe:       false\n\t\t},\n\n\t\tjukebox: {\n\t\t\tchannels: 8,\n\t\t\tmusic:    true,\n\t\t\tsound:    true\n\t\t},\n\n\t\tloop: {\n\t\t\trender: 60,\n\t\t\tupdate: 60\n\t\t},\n\n\t\trenderer: {\n\t\t\twidth:      null,\n\t\t\theight:     null,\n\t\t\tid:         'game',\n\t\t\tbackground: '#222222'\n\t\t},\n\n\t\tstorage: {\n\t\t\tid:    'game',\n\t\t\tmodel: {},\n\t\t\ttype:  lychee.Storage.TYPE.persistent\n\t\t},\n\n\t\tviewport: {\n\t\t\tfullscreen: false\n\t\t},\n\n\t\tclient: null,\n\t\tserver: null\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(settings) {\n\n\t\tthis.settings = lychee.extendunlink({}, _defaults, settings);\n\t\tthis.defaults = lychee.extendunlink({}, this.settings);\n\n\t\tthis.client   = null;\n\t\tthis.input    = null;\n\t\tthis.jukebox  = null;\n\t\tthis.loop     = null;\n\t\tthis.renderer = null;\n\t\tthis.storage  = null;\n\t\tthis.viewport = null;\n\n\t\tthis.__states = {};\n\t\tthis.__state  = null;\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tfor (var id in blob.states) {\n\n\t\t\t\tvar stateblob = blob.states[id];\n\n\t\t\t\tfor (var a = 0, al = stateblob.arguments.length; a < al; a++) {\n\t\t\t\t\tif (stateblob.arguments[a] === '#MAIN') {\n\t\t\t\t\t\tstateblob.arguments[a] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.setState(id, lychee.deserialize(stateblob));\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = lychee.extendunlink({}, this.settings);\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.input !== null)    blob.input    = lychee.serialize(this.input);\n\t\t\tif (this.viewport !== null) blob.viewport = lychee.serialize(this.viewport);\n\n\n\t\t\tif (Object.keys(this.__states).length > 0) {\n\n\t\t\t\tblob.states = {};\n\n\t\t\t\tfor (var id in this.__states) {\n\t\t\t\t\tblob.states[id] = lychee.serialize(this.__states[id]);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Main',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * LOOP INTEGRATION\n\t\t */\n\n\t\trender: function(clock, delta) {\n\n\t\t\tif (this.__state !== null) {\n\t\t\t\tthis.__state.render(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tif (this.__state !== null) {\n\t\t\t\tthis.__state.update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * VIEWPORT INTEGRATION\n\t\t */\n\n\t\tshow: function() {\n\n\t\t\tvar loop = this.loop;\n\t\t\tif (loop !== null) {\n\t\t\t\tloop.resume();\n\t\t\t}\n\n\t\t\tvar state = this.getState();\n\t\t\tif (state !== null) {\n\t\t\t\tstate.show();\n\t\t\t}\n\n\t\t},\n\n\t\thide: function() {\n\n\t\t\tvar loop = this.loop;\n\t\t\tif (loop !== null) {\n\t\t\t\tloop.pause();\n\t\t\t}\n\n\t\t\tvar state = this.getState();\n\t\t\tif (state !== null) {\n\t\t\t\tstate.hide();\n\t\t\t}\n\n\t\t},\n\n\t\treshape: function(orientation, rotation) {\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tvar settings = this.settings;\n\t\t\t\tif (settings.renderer !== null) {\n\t\t\t\t\trenderer.setWidth(settings.renderer.width);\n\t\t\t\t\trenderer.setHeight(settings.renderer.height);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfor (var id in this.__states) {\n\n\t\t\t\tvar state = this.__states[id];\n\n\t\t\t\tstate.reshape(\n\t\t\t\t\torientation,\n\t\t\t\t\trotation\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\tinit: function() {\n\n\t\t\tvar async      = false;\n\t\t\tvar clientdata = this.settings.client;\n\t\t\tvar serverdata = this.settings.server;\n\n\t\t\tif (this.client === null && typeof clientdata === 'string') {\n\t\t\t\t_load_client.call(this, clientdata);\n\t\t\t\tasync = true;\n\t\t\t}\n\n\t\t\tif (this.server === null && typeof serverdata === 'string') {\n\t\t\t\t_load_server.call(this, serverdata);\n\t\t\t\tasync = true;\n\t\t\t}\n\n\n\t\t\tif (async === false) {\n\t\t\t\t_initialize.call(this);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * STATE MANAGEMENT\n\t\t */\n\n\t\tsetState: function(id, state) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (lychee.interfaceof(lychee.game.State, state)) {\n\n\t\t\t\tif (id !== null) {\n\n\t\t\t\t\tthis.__states[id] = state;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\t\t\t\treturn this.__states[id] || null;\n\t\t\t}\n\n\n\t\t\treturn this.__state || null;\n\n\t\t},\n\n\t\tisState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\t\t\t\treturn this.__state === this.__states[id];\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__states[id] !== undefined) {\n\n\t\t\t\tdelete this.__states[id];\n\n\t\t\t\tif (this.__state === this.__states[id]) {\n\t\t\t\t\tthis.changeState(null);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tchangeState: function(id, data) {\n\n\t\t\tid   = typeof id === 'string' ? id   : null;\n\t\t\tdata = data instanceof Object ? data : null;\n\n\n\t\t\tvar oldstate = this.__state;\n\t\t\tvar newstate = this.__states[id] || null;\n\n\t\t\tif (newstate !== null) {\n\n\t\t\t\tif (oldstate !== null) {\n\t\t\t\t\toldstate.leave();\n\t\t\t\t}\n\n\t\t\t\tif (newstate !== null) {\n\t\t\t\t\tnewstate.enter(data);\n\t\t\t\t}\n\n\t\t\t\tthis.__state = newstate;\n\n\t\t\t} else {\n\n\t\t\t\tif (oldstate !== null) {\n\t\t\t\t\toldstate.leave();\n\t\t\t\t}\n\n\t\t\t\tthis.__state = null;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.event.Emitter":{"constructor":"lychee.Definition","arguments":["lychee.event.Emitter"],"blob":{"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _unbind = function(type, callback, scope) {\n\n\t\tif (this.___events[type] !== undefined) {\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var e = 0, el = this.___events[type].length; e < el; e++) {\n\n\t\t\t\tvar entry = this.___events[type][e];\n\n\t\t\t\tif ((callback === null || entry.callback === callback) && (scope === null || entry.scope === scope)) {\n\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\tthis.___events[type].splice(e, 1);\n\t\t\t\t\tel--;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function() {\n\n\t\tthis.___events = {};\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tbind: function(type, callback, scope, once) {\n\n\t\t\ttype     = typeof type === 'string'     ? type     : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : this;\n\t\t\tonce     = once === true;\n\n\n\t\t\tif (type === null || callback === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tvar passAction = false;\n\t\t\tvar passSelf   = false;\n\n\t\t\tif (type.charAt(0) === '@') {\n\t\t\t\ttype = type.substr(1, type.length - 1);\n\t\t\t\tpassAction = true;\n\t\t\t} else if (type.charAt(0) === '#') {\n\t\t\t\ttype = type.substr(1, type.length - 1);\n\t\t\t\tpassSelf = true;\n\t\t\t}\n\n\n\t\t\tif (this.___events[type] === undefined) {\n\t\t\t\tthis.___events[type] = [];\n\t\t\t}\n\n\n\t\t\tthis.___events[type].push({\n\t\t\t\tpassAction: passAction,\n\t\t\t\tpassSelf:   passSelf,\n\t\t\t\tcallback:   callback,\n\t\t\t\tscope:      scope,\n\t\t\t\tonce:       once\n\t\t\t});\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\ttrigger: function(type, data) {\n\n\t\t\ttype = typeof type === 'string' ? type : null;\n\t\t\tdata = data instanceof Array    ? data : null;\n\n\n\t\t\tif (this.___events[type] !== undefined) {\n\n\t\t\t\tvar value = undefined;\n\n\t\t\t\tfor (var e = 0; e < this.___events[type].length; e++) {\n\n\t\t\t\t\tvar args  = [];\n\t\t\t\t\tvar entry = this.___events[type][e];\n\n\t\t\t\t\tif (entry.passAction === true) {\n\n\t\t\t\t\t\targs.push(type);\n\t\t\t\t\t\targs.push(this);\n\n\t\t\t\t\t} else if (entry.passSelf === true) {\n\n\t\t\t\t\t\targs.push(this);\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (data !== null) {\n\t\t\t\t\t\targs.push.apply(args, data);\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar result = entry.callback.apply(entry.scope, args);\n\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (entry.once === true) {\n\n\t\t\t\t\t\tif (this.unbind(type, entry.callback, entry.scope) === true) {\n\t\t\t\t\t\t\te--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\treturn value;\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tunbind: function(type, callback, scope) {\n\n\t\t\ttype     = typeof type === 'string'     ? type     : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : null;\n\n\n\t\t\tvar found = false;\n\n\t\t\tif (type !== null) {\n\n\t\t\t\tfound = _unbind.call(this, type, callback, scope);\n\n\t\t\t} else {\n\n\t\t\t\tfor (type in this.___events) {\n\n\t\t\t\t\tvar result = _unbind.call(this, type, callback, scope);\n\t\t\t\t\tif (result === true) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.Input":{"constructor":"lychee.Definition","arguments":["lychee.Input"],"blob":{"tags":{"platform":"nodejs"},"includes":["lychee.event.Emitter"],"supports":"function (lychee, global) {\n\n\tif (typeof process !== 'undefined') {\n\n\t\tif (typeof process.stdin === 'object' && typeof process.stdin.on === 'function') {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\n\treturn false;\n\n}","exports":"function (lychee, global) {\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _instances = [];\n\n\tvar _listeners = {\n\n\t\tkeyboard: function(key) {\n\n\t\t\t// This is apparently a hack to have a TTY conform behaviour\n\t\t\tif (key.ctrl === true && key.name === 'c') {\n\n\t\t\t\tprocess.exit();\n\n\t\t\t} else {\n\n\t\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t\t_process_key.call(_instances[i], key.name, key.ctrl, key.meta, key.shift);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\t(function() {\n\n\t\tprocess.stdin.on('keypress', _listeners.keyboard);\n\n\n\t\tif (lychee.debug === true) {\n\t\t\tconsole.info('lychee.Input: Supported methods are Keyboard');\n\t\t}\n\n\t})();\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\t// TODO: Modifier support is missing, I have no idea how to work around the TTY behaviour.\n\n\tvar _process_key = function(key, ctrl, alt, shift) {\n\n\t\tif (this.key === false) return false;\n\n\n\t\t// 2. Only fire after the enforced delay\n\t\tvar delta = Date.now() - this.__clock.key;\n\t\tif (delta < this.delay) {\n\t\t\treturn;\n\t\t}\n\n\n\t\t// 3. Check for current key being a modifier\n\t\tif (this.keymodifier === false) {\n\n\t\t\tif (key === 'ctrl' || key === 'meta' || key === 'shift') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar name = '';\n\n\t\tif (ctrl  === true) name += 'ctrl-';\n\t\tif (alt   === true) name += 'alt-';\n\t\tif (shift === true) name += 'shift-';\n\n\t\tname += key.toLowerCase();\n\n\n\n\t\tvar handled = false;\n\n\t\tif (key !== null) {\n\n\t\t\t// allow bind('key') and bind('ctrl-a');\n\n\t\t\thandled = this.trigger('key', [ key, name, delta ]) || handled;\n\t\t\thandled = this.trigger(name,  [ delta ])            || handled;\n\n\n\t\t\tif (handled === true) {\n\n\t\t\t\tif (lychee.debug === true) {\n\t\t\t\t\tthis.__history.key.push([ Date.now(), key, name, delta ]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.__clock.key = Date.now();\n\n\n\t\treturn handled;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.delay       = 0;\n\t\tthis.key         = false;\n\t\tthis.keymodifier = false;\n\t\tthis.touch       = false;\n\t\tthis.swipe       = false;\n\n\t\tthis.__clock  = {\n\t\t\tkey:   Date.now(),\n\t\t\ttouch: Date.now(),\n\t\t\tswipe: Date.now()\n\t\t};\n\t\tthis.__history = {\n\t\t\tkey:   [],\n\t\t\ttouch: [],\n\t\t\tswipe: []\n\t\t};\n\n\n\t\tthis.setDelay(settings.delay);\n\t\tthis.setKey(settings.key);\n\t\tthis.setKeyModifier(settings.keymodifier);\n\t\tthis.setTouch(settings.touch);\n\t\tthis.setSwipe(settings.swipe);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\t_instances.push(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tdestroy: function() {\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var i = 0, il = _instances.length; i < il; i++) {\n\n\t\t\t\tif (_instances[i] === this) {\n\t\t\t\t\t_instances.splice(i, 1);\n\t\t\t\t\tfound = true;\n\t\t\t\t\til--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.unbind();\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.delay !== 0)           settings.delay       = this.delay;\n\t\t\tif (this.key !== false)         settings.key         = this.key;\n\t\t\tif (this.keymodifier !== false) settings.keymodifier = this.keymodifier;\n\t\t\tif (this.touch !== false)       settings.touch       = this.touch;\n\t\t\tif (this.swipe !== false)       settings.swipe       = this.swipe;\n\n\n\t\t\tif (this.__history.key.length > 0 || this.__history.touch.length > 0 || this.__history.swipe.length > 0) {\n\n\t\t\t\tblob.history = {};\n\n\t\t\t\tif (this.__history.key.length > 0) {\n\n\t\t\t\t\tblob.history.key = [];\n\n\t\t\t\t\tfor (var k = 0, kl = this.__history.key.length; k < kl; k++) {\n\t\t\t\t\t\tblob.history.key.push(this.__history.key[k]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.touch.length > 0) {\n\n\t\t\t\t\tblob.history.touch = [];\n\n\t\t\t\t\tfor (var t = 0, tl = this.__history.touch.length; t < tl; t++) {\n\t\t\t\t\t\tblob.history.touch.push(this.__history.touch[t]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.swipe.length > 0) {\n\n\t\t\t\t\tblob.history.swipe = [];\n\n\t\t\t\t\tfor (var s = 0, sl = this.__history.swipe.length; s < sl; s++) {\n\t\t\t\t\t\tblob.history.swipe.push(this.__history.swipe[s]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Input',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tsetDelay: function(delay) {\n\n\t\t\tdelay = typeof delay === 'number' ? delay : null;\n\n\n\t\t\tif (delay !== null) {\n\n\t\t\t\tthis.delay = delay;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetKey: function(key) {\n\n\t\t\tif (key === true || key === false) {\n\n\t\t\t\tthis.key = key;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetKeyModifier: function(keymodifier) {\n\n\t\t\tif (keymodifier === true || keymodifier === false) {\n\n\t\t\t\tthis.keymodifier = keymodifier;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetTouch: function(touch) {\n\t\t\treturn false;\n\t\t},\n\n\t\tsetSwipe: function(swipe) {\n\t\t\treturn false;\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.Storage":{"constructor":"lychee.Definition","arguments":["lychee.Storage"],"blob":{"tags":{"platform":"nodejs"},"includes":["lychee.event.Emitter"],"supports":"function (lychee, global) {\n\n\tvar fs = require('fs');\n\tif (typeof fs.readFileSync === 'function' && typeof fs.writeFileSync === 'function') {\n\t\treturn true;\n\t}\n\n\treturn false;\n\n}","exports":"function (lychee, global) {\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _persistent = {};\n\tvar _temporary  = {};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\tvar _read_persistent  = function() { return false; };\n\tvar _write_persistent = function() { return false; };\n\n\t(function() {\n\n\t\tvar _fs   = require('fs');\n\t\tvar _path = require('path');\n\n\n\t\tvar read = 'readFileSync' in _fs;\n\t\tif (read === true) {\n\n\t\t\t_read_persistent = function() {\n\n\t\t\t\tvar url = _path.normalize(process.cwd() + '/lychee.store');\n\n\n\t\t\t\tvar raw = null;\n\t\t\t\ttry {\n\t\t\t\t\traw = _fs.readFileSync(url, 'utf8');\n\t\t\t\t} catch(e) {\n\t\t\t\t\traw = null;\n\t\t\t\t}\n\n\n\t\t\t\tvar buffer = null;\n\t\t\t\ttry {\n\t\t\t\t\tbuffer = JSON.parse(raw);\n\t\t\t\t} catch(e) {\n\t\t\t\t\tbuffer = null;\n\t\t\t\t}\n\n\n\t\t\t\tif (buffer !== null) {\n\n\t\t\t\t\t// TODO: Evaluate if asynchronous update of deep hierarchies makes sense\n\n\t\t\t\t\tfor (var id in buffer) {\n\t\t\t\t\t\t_persistent[id] = buffer[id];\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}\n\n\n\t\tvar write = 'writeFileSync' in _fs;\n\t\tif (write === true) {\n\n\t\t\t_write_persistent = function() {\n\n\t\t\t\tvar buffer = JSON.stringify(_persistent, null, '\\t');\n\t\t\t\tvar url    = _path.normalize(process.cwd() + '/lychee.store');\n\n\n\t\t\t\tvar result = false;\n\t\t\t\ttry {\n\t\t\t\t\tresult = _fs.writeFileSync(url, buffer, 'utf8');\n\t\t\t\t} catch(e) {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\n\n\t\t\t\treturn result;\n\n\t\t\t};\n\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (read && write) methods.push('Persistent');\n\t\t\tif (_temporary)    methods.push('Temporary');\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.Storage: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.info('lychee.Storage: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\n\t\t_read_persistent();\n\n\t})();\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _read_storage = function() {\n\n\t\tvar id   = this.id;\n\t\tvar blob = null;\n\n\n\t\tvar type = this.type;\n\t\tif (type === Class.TYPE.persistent) {\n\t\t\tblob = _persistent[id] || null;\n\t\t} else if (type === Class.TYPE.temporary) {\n\t\t\tblob = _temporary[id]  || null;\n\t\t}\n\n\n\t\tif (blob !== null) {\n\n\t\t\tif (this.model === null) {\n\n\t\t\t\tif (blob['@model'] instanceof Object) {\n\t\t\t\t\tthis.model = blob['@model'];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar document = this.__document;\n\t\t\tif (document.index === 0) {\n\n\t\t\t\tif (blob['@document'] instanceof Object) {\n\t\t\t\t\tthis.__document = blob['@document'];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar objects = this.__objects;\n\t\t\tif (objects.length === 0 || objects.length !== blob['@objects'].length) {\n\n\t\t\t\tif (blob['@objects'] instanceof Array) {\n\n\t\t\t\t\tobjects = blob['@objects'];\n\t\t\t\t\tthis.__objects = [];\n\n\t\t\t\t\tfor (var o = 0, ol = objects.length; o < ol; o++) {\n\t\t\t\t\t\tthis.__objects.push(objects[o]);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.trigger('sync', [ this.__objects ]);\n\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _write_storage = function() {\n\n\t\tvar operations = this.__operations;\n\t\tif (operations.length !== 0) {\n\n\t\t\twhile (operations.length > 0) {\n\n\t\t\t\tvar operation = operations.shift();\n\t\t\t\tif (operation.type === 'insert') {\n\n\t\t\t\t\tthis.__document.index++;\n\t\t\t\t\tthis.__objects.push(operation.object);\n\t\t\t\t\tthis.trigger('insert', [ operation.index, operation.object ]);\n\n\t\t\t\t} else if (operation.type === 'update') {\n\n\t\t\t\t\tif (this.__objects[operation.index] !== operation.object) {\n\t\t\t\t\t\tthis.__objects[operation.index] = operation.object;\n\t\t\t\t\t\tthis.trigger('update', [ operation.index, operation.object ]);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (operation.type === 'remove') {\n\n\t\t\t\t\tthis.__document.index--;\n\t\t\t\t\tthis.__objects.splice(operation.index, 1);\n\t\t\t\t\tthis.trigger('remove', [ operation.index, operation.object ]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tthis.__document.time = Date.now();\n\n\n\t\t\tvar id   = this.id;\n\t\t\tvar blob = {\n\t\t\t\t'@document': this.__document,\n\t\t\t\t'@model':    this.model,\n\t\t\t\t'@objects':  this.__objects\n\t\t\t};\n\n\n\t\t\tvar type = this.type;\n\t\t\tif (type === Class.TYPE.persistent) {\n\n\t\t\t\t_persistent[id] = blob;\n\t\t\t\t_write_persistent();\n\n\t\t\t} else if (type === Class.TYPE.temporary) {\n\n\t\t\t\t_temporary[id] = blob;\n\n\t\t\t}\n\n\n\t\t\tthis.trigger('sync', [ this.__objects ]);\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _id = 0;\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.id    = 'lychee-Storage-' + _id++;\n\t\tthis.model = {};\n\t\tthis.type  = Class.TYPE.persistent;\n\n\t\tthis.__document   = { index: 0, time: Date.now() };\n\t\tthis.__objects    = [];\n\t\tthis.__operations = [];\n\n\n\t\tthis.setId(settings.id);\n\t\tthis.setModel(settings.model);\n\t\tthis.setType(settings.type);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\tsettings = null;\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\t_read_storage.call(this);\n\n\t};\n\n\n\tClass.TYPE = {\n\t\tpersistent: 0,\n\t\ttemporary:  1\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tsync: function(force) {\n\n\t\t\tforce = force === true;\n\n\n\t\t\tvar result = _read_storage.call(this);\n\t\t\tif (result === true) {\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (force === true) {\n\n\t\t\t\t\tthis.trigger('sync', [ this.__objects ]);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tif (blob.document instanceof Object) {\n\t\t\t\tthis.__document.index = blob.document.index;\n\t\t\t\tthis.__document.time  = blob.document.time;\n\t\t\t}\n\n\t\t\tif (blob.objects instanceof Array) {\n\n\t\t\t\tthis.__objects = [];\n\n\t\t\t\tfor (var o = 0, ol = blob.objects.length; o < ol; o++) {\n\n\t\t\t\t\tvar object = blob.objects[o];\n\t\t\t\t\tif (lychee.interfaceof(this.model, object)) {\n\t\t\t\t\t\tthis.__objects.push(object);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.id.substr(0, 15) !== 'lychee-Storage-') settings.id    = this.id;\n\t\t\tif (Object.keys(this.model).length !== 0)        settings.model = this.model;\n\t\t\tif (this.type !== Class.TYPE.persistent)         settings.type  = this.type;\n\n\n\t\t\tif (this.__document.index > 0) {\n\n\t\t\t\tblob.document = {};\n\t\t\t\tblob.document.index = this.__document.index;\n\t\t\t\tblob.document.time  = this.__document.time;\n\n\t\t\t}\n\n\t\t\tif (this.__objects.length > 0) {\n\n\t\t\t\tblob.objects = {};\n\n\t\t\t\tfor (var o = 0, ol = this.__objects.length; o < ol; o++) {\n\n\t\t\t\t\tvar object = this.__objects[o];\n\t\t\t\t\tif (object instanceof Object) {\n\t\t\t\t\t\tblob.objects.push(JSON.parse(JSON.stringify(object)));\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Storage',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tcreate: function() {\n\t\t\treturn lychee.extendunlink({}, this.model);\n\t\t},\n\n\t\tfilter: function(callback, scope) {\n\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : this;\n\n\n\t\t\tvar filtered = [];\n\n\t\t\tfor (var o = 0, ol = this.__objects.length; o < ol; o++) {\n\n\t\t\t\tvar object = this.__objects[o];\n\t\t\t\tif (callback !== null) {\n\n\t\t\t\t\tif (callback.call(scope, o, object) === true) {\n\t\t\t\t\t\tfiltered.push(object);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tfiltered.push(object);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn filtered;\n\n\t\t},\n\n\t\tinsert: function(object) {\n\n\t\t\t// This uses the diff method, because properties can be null\n\t\t\tobject = lychee.diff(this.model, object) === false ? object : null;\n\n\n\t\t\tif (object !== null) {\n\n\t\t\t\tvar index = this.__objects.indexOf(object);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.__operations.push({\n\t\t\t\t\t\ttype:   'insert',\n\t\t\t\t\t\tindex:  this.__objects.length,\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t});\n\n\n\t\t\t\t\t_write_storage.call(this);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tupdate: function(object) {\n\n\t\t\t// This uses the diff method, because properties can be null\n\t\t\tobject = lychee.diff(this.model, object) === false ? object : null;\n\n\n\t\t\tif (object !== null) {\n\n\t\t\t\tvar index = this.__objects.indexOf(object);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.__operations.push({\n\t\t\t\t\t\ttype:   'update',\n\t\t\t\t\t\tindex:  index,\n\t\t\t\t\t\tobject: object\n\t\t\t\t\t});\n\n\n\t\t\t\t\t_write_storage.call(this);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tget: function(index) {\n\n\t\t\tindex = typeof index === 'number' ? (index | 0) : null;\n\n\n\t\t\tif (index !== null) {\n\n\t\t\t\tvar object = this.__objects[index] || null;\n\t\t\t\tif (object !== null) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tremove: function(index, object) {\n\n\t\t\tindex = typeof index === 'number' ? (index | 0) : this.__objects.indexOf(object);\n\n\n\t\t\tif (index >= 0 && index < this.__objects.length) {\n\n\t\t\t\tthis.__operations.push({\n\t\t\t\t\ttype:   'remove',\n\t\t\t\t\tindex:  index,\n\t\t\t\t\tobject: this.__objects[index]\n\t\t\t\t});\n\n\n\t\t\t\t_write_storage.call(this);\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetId: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tthis.id = id;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetModel: function(model) {\n\n\t\t\tmodel = model instanceof Object ? model : null;\n\n\n\t\t\tif (model !== null) {\n\n\t\t\t\tthis.model = JSON.parse(JSON.stringify(model));\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetType: function(type) {\n\n\t\t\tif (lychee.enumof(Class.TYPE, type)) {\n\n\t\t\t\tthis.type = type;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.Renderer":{"constructor":"lychee.Definition","arguments":["lychee.Renderer"],"blob":{"tags":{"platform":"nodejs"},"supports":"function (lychee, global) {\n\n\tif (typeof process !== 'undefined') {\n\n\t\tif (typeof process.stdout === 'object') {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\n\treturn false;\n\n}","exports":"function (lychee, global, attachments) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _color_cache = {};\n\n\tvar _is_color = function(color) {\n\n\t\tif (typeof color === 'string') {\n\n\t\t\tif (color.match(/(#[AaBbCcDdEeFf0-9]{6})/) || color.match(/(#[AaBbCcDdEeFf0-9]{8})/)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _hex_to_rgba = function(hex) {\n\n\t\tif (_color_cache[hex] !== undefined) {\n\t\t\treturn _color_cache[hex];\n\t\t}\n\n\t\tvar rgba = [ 0, 0, 0, 255 ];\n\n\t\tif (typeof hex === 'string') {\n\n\t\t\tif (hex.length === 7) {\n\n\t\t\t\trgba[0] = parseInt(hex[1] + hex[2], 16);\n\t\t\t\trgba[1] = parseInt(hex[3] + hex[4], 16);\n\t\t\t\trgba[2] = parseInt(hex[5] + hex[6], 16);\n\t\t\t\trgba[3] = 255;\n\n\t\t\t} else if (hex.length === 9) {\n\n \t\t\t\trgba[0] = parseInt(hex[1] + hex[2], 16);\n\t\t\t\trgba[1] = parseInt(hex[3] + hex[4], 16);\n\t\t\t\trgba[2] = parseInt(hex[5] + hex[6], 16);\n\t\t\t\trgba[3] = parseInt(hex[7] + hex[8], 16);\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar color = 'rgba(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ',' + (rgba[3] / 255) + ')';\n\n\t\t_color_cache[hex] = color;\n\n\n\t\treturn color;\n\n\t};\n\n\tvar _draw_ctx = function(x, y, value) {\n\n\t\tif (x >= 0 && x < this[0].length && y >= 0 && y < this.length) {\n\t\t\tthis[y][x] = value;\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * STRUCTS\n\t */\n\n\tvar _buffer = function(width, height) {\n\n\t\tthis.width  = typeof width === 'number'  ? width  : 1;\n\t\tthis.height = typeof height === 'number' ? height : 1;\n\n\n\t\tthis.__ctx = [];\n\n\n\t\tthis.resize();\n\n\t};\n\n\t_buffer.prototype = {\n\n\t\tclear: function() {\n\n\t\t\tvar ctx    = this.__ctx;\n\t\t\tvar width  = this.width;\n\t\t\tvar height = this.height;\n\n\t\t\tfor (var y = 0; y < this.height; y++) {\n\n\t\t\t\tfor (var x = 0; x < this.width; x++) {\n\t\t\t\t\tthis.__ctx[y][x] = ' ';\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tresize: function(width, height) {\n\n\t\t\tthis.__ctx.length = 0;\n\n\t\t\t// TODO: Remove this\n\t\t\t// this.__ctx = [];\n\n\n\t\t\tfor (var y = 0; y < this.height; y++) {\n\n\t\t\t\tvar line = new Array(this.width);\n\t\t\t\tfor (var x = 0; x < this.width; x++) {\n\t\t\t\t\tline[x] = ' ';\n\t\t\t\t}\n\n\t\t\t\tthis.__ctx.push(line);\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _id = 0;\n\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.alpha      = 1.0;\n\t\tthis.background = '#000000';\n\t\tthis.id         = 'lychee-Renderer-' + _id++;\n\t\tthis.width      = null;\n\t\tthis.height     = null;\n\t\tthis.offset     = { x: 0, y: 0 };\n\n\n\t\tthis.__buffer = this.createBuffer(0, 0);\n\t\tthis.__ctx    = this.__buffer.__ctx;\n\n\n\t\tthis.setAlpha(settings.alpha);\n\t\tthis.setBackground(settings.background);\n\t\tthis.setId(settings.id);\n\t\tthis.setWidth(settings.width);\n\t\tthis.setHeight(settings.height);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.alpha !== 1.0)                           settings.alpha      = this.alpha;\n\t\t\tif (this.background !== '#000000')                settings.background = this.background;\n\t\t\tif (this.id.substr(0, 16) !== 'lychee-Renderer-') settings.id         = this.id;\n\t\t\tif (this.width !== null)                          settings.width      = this.width;\n\t\t\tif (this.height !== null)                         settings.height     = this.height;\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Renderer',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * SETTERS AND GETTERS\n\t\t */\n\n\t\tsetAlpha: function(alpha) {\n\n\t\t\talpha = typeof alpha === 'number' ? alpha : null;\n\n\n\t\t\tif (alpha !== null) {\n\n\t\t\t\tif (alpha >= 0 && alpha <= 1) {\n\t\t\t\t\tthis.alpha = alpha;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetBackground: function(color) {\n\n\t\t\tcolor = _is_color(color) === true ? color : null;\n\n\n\t\t\tif (color !== null) {\n\t\t\t\tthis.background = color;\n\t\t\t}\n\n\t\t},\n\n\t\tsetId: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\t\t\t\tthis.id = id;\n\t\t\t}\n\n\t\t},\n\n\t\tsetWidth: function(width) {\n\n\t\t\twidth = typeof width === 'number' ? width : null;\n\n\n\t\t\tif (width !== null) {\n\t\t\t\tthis.width = width;\n\t\t\t} else {\n\t\t\t\tthis.width = process.stdout.columns - 1;\n\t\t\t}\n\n\n\t\t\tthis.__buffer.width = this.width;\n\t\t\tthis.__buffer.resize();\n\n\t\t\tthis.offset.x = 0;\n\n\t\t},\n\n\t\tsetHeight: function(height) {\n\n\t\t\theight = typeof height === 'number' ? height : null;\n\n\n\t\t\tif (height !== null) {\n\t\t\t\tthis.height = height;\n\t\t\t} else {\n\t\t\t\tthis.height = process.stdout.rows - 1;\n\t\t\t}\n\n\n\t\t\tthis.__buffer.height = this.height;\n\t\t\tthis.__buffer.resize();\n\n\t\t\tthis.offset.y = 0;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * BUFFER INTEGRATION\n\t\t */\n\n\t\tclear: function(buffer) {\n\n\t\t\tbuffer = buffer instanceof _buffer ? buffer : null;\n\n\n\t\t\tif (buffer !== null) {\n\n\t\t\t\tbuffer.clear();\n\n\t\t\t} else {\n\n\t\t\t\tprocess.stdout.write('\\u001B[2J\\u001B[0;0f');\n\n\t\t\t\tthis.__buffer.clear();\n\n\t\t\t}\n\n\t\t},\n\n\t\tflush: function() {\n\n\t\t\tvar ctx = this.__ctx;\n\n\t\t\tvar line = ctx[0];\n\t\t\tvar info = this.width + 'x' + this.height;\n\n\t\t\tfor (var i = 0; i < info.length; i++) {\n\t\t\t\tline[i] = info[i];\n\t\t\t}\n\n\n\t\t\tfor (var y = 0; y < this.height; y++) {\n\t\t\t\tprocess.stdout.write(ctx[y].join('') + '\\n');\n\t\t\t}\n\n\t\t},\n\n\t\tcreateBuffer: function(width, height) {\n\t\t\treturn new _buffer(width, height);\n\t\t},\n\n\t\tsetBuffer: function(buffer) {\n\n\t\t\tbuffer = buffer instanceof _buffer ? buffer : null;\n\n\n\t\t\tif (buffer !== null) {\n\t\t\t\tthis.__ctx = buffer.__ctx;\n\t\t\t} else {\n\t\t\t\tthis.__ctx = this.__buffer.__ctx;\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * DRAWING API\n\t\t */\n\n\t\tdrawArc: function(x, y, start, end, radius, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\t\t\tvar pi2 = Math.PI * 2;\n\n\n\t\t\t// TODO: Implement arc-drawing ASCII art algorithm\n\n\t\t},\n\n\t\tdrawBox: function(x1, y1, x2, y2, color, background, lineWidth) {\n\n\t\t\tif (this.alpha < 0.5) return;\n\n\t\t\tx1 = x1 | 0;\n\t\t\ty1 = y1 | 0;\n\t\t\tx2 = x2 | 0;\n\t\t\ty2 = y2 | 0;\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\n\n\t\t\tif (background === true) {\n\n\t\t\t\tfor (x = x1 + 1; x < x2; x++) {\n\n\t\t\t\t\tfor (y = y1 + 1; y < y2; y++) {\n\t\t\t\t\t\t_draw_ctx.call(ctx, x, y, '+');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// top - right - bottom - left\n\n\t\t\ty = y1;\n\t\t\tfor (x = x1 + 1; x < x2; x++) _draw_ctx.call(ctx, x, y, '-');\n\n\t\t\tx = x2;\n\t\t\tfor (y = y1 + 1; y < y2; y++) _draw_ctx.call(ctx, x, y, '|');\n\n\t\t\ty = y2;\n\t\t\tfor (x = x1 + 1; x < x2; x++) _draw_ctx.call(ctx, x, y, '-');\n\n\t\t\tx = x1;\n\t\t\tfor (y = y1 + 1; y < y2; y++) _draw_ctx.call(ctx, x, y, '|');\n\n\t\t},\n\n\t\tdrawBuffer: function(x1, y1, buffer) {\n\n\t\t\tbuffer = buffer instanceof _buffer ? buffer : null;\n\n\n\t\t\tif (buffer !== null) {\n\n\t\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t\tvar x2 = Math.min(x1 + buffer.width,  this.__buffer.width);\n\t\t\t\tvar y2 = Math.min(y1 + buffer.height, this.__buffer.height);\n\n\n\t\t\t\tfor (var y = y1; y < y2; y++) {\n\n\t\t\t\t\tfor (var x = x1; x < x2; x++) {\n\t\t\t\t\t\tthis.__ctx[y][x] = buffer.__ctx[y - y1][x - x1];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (lychee.debug === true) {\n\n\t\t\t\t\tthis.drawBox(\n\t\t\t\t\t\tx1,\n\t\t\t\t\t\ty1,\n\t\t\t\t\t\tx1 + buffer.width,\n\t\t\t\t\t\ty1 + buffer.height,\n\t\t\t\t\t\t'#00ff00',\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t1\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdrawCircle: function(x, y, radius, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t// TODO: Implement circle-drawing ASCII art algorithm\n\n\t\t},\n\n\t\tdrawLight: function(x, y, radius, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) ? _hex_to_rgba(color) : 'rgba(255,255,255,1.0)';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t// TODO: Implement light-drawing ASCII art algorithm\n\n\t\t},\n\n\t\tdrawLine: function(x1, y1, x2, y2, color, lineWidth) {\n\n\t\t\tcolor     = _is_color(color) === true ? color : '#000000';\n\t\t\tlineWidth = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t// TODO: Implement line-drawing ASCII art algorithm\n\n\t\t},\n\n\t\tdrawTriangle: function(x1, y1, x2, y2, x3, y3, color, background, lineWidth) {\n\n\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\tbackground = background === true;\n\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t// TODO: Implement triangle-drawing ASCII art algorithm\n\n\t\t},\n\n\t\t// points, x1, y1, [ ... x(a), y(a) ... ], [ color, background, lineWidth ]\n\t\tdrawPolygon: function(points, x1, y1) {\n\n\t\t\tvar l = arguments.length;\n\n\t\t\tif (points > 3) {\n\n\t\t\t\tvar optargs = l - (points * 2) - 1;\n\n\n\t\t\t\tvar color, background, lineWidth;\n\n\t\t\t\tif (optargs === 3) {\n\n\t\t\t\t\tcolor      = arguments[l - 3];\n\t\t\t\t\tbackground = arguments[l - 2];\n\t\t\t\t\tlineWidth  = arguments[l - 1];\n\n\t\t\t\t} else if (optargs === 2) {\n\n\t\t\t\t\tcolor      = arguments[l - 2];\n\t\t\t\t\tbackground = arguments[l - 1];\n\n\t\t\t\t} else if (optargs === 1) {\n\n\t\t\t\t\tcolor      = arguments[l - 1];\n\n\t\t\t\t}\n\n\n\t\t\t\tcolor      = _is_color(color) === true ? color : '#000000';\n\t\t\t\tbackground = background === true;\n\t\t\t\tlineWidth  = typeof lineWidth === 'number' ? lineWidth : 1;\n\n\n\t\t\t\tvar ctx = this.__ctx;\n\n\n\t\t\t\t// TODO: Implement polygon-drawing ASCII art algorithm\n\n\t\t\t}\n\n\t\t},\n\n\t\tdrawSprite: function(x1, y1, texture, map) {\n\n\t\t\ttexture = texture instanceof Texture ? texture : null;\n\t\t\tmap     = map instanceof Object      ? map     : null;\n\n\n\t\t\tif (texture !== null) {\n\n\t\t\t\tif (map === null) {\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif (lychee.debug === true) {\n\n\t\t\t\t\t\tthis.drawBox(\n\t\t\t\t\t\t\tx1,\n\t\t\t\t\t\t\ty1,\n\t\t\t\t\t\t\tx1 + map.w,\n\t\t\t\t\t\t\ty1 + map.h,\n\t\t\t\t\t\t\t'#ff0000',\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t1\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tdrawText: function(x1, y1, text, font, center) {\n\n\t\t\tfont   = font instanceof Font ? font : null;\n\t\t\tcenter = center === true;\n\n\n\t\t\tif (font !== null) {\n\n\t\t\t\tif (center === true) {\n\n\t\t\t\t\tvar dim = font.measure(text);\n\n\t\t\t\t\tx1 -= dim.realwidth / 2;\n\t\t\t\t\ty1 -= (dim.realheight - font.baseline) / 2;\n\n\t\t\t\t}\n\n\n\t\t\t\ty1 -= font.baseline / 2;\n\n\n\t\t\t\tx1 = x1 | 0;\n\t\t\t\ty1 = y1 | 0;\n\n\n\t\t\t\tvar ctx = this.__ctx;\n\t\t\t\tvar margin  = 0;\n\t\t\t\tvar texture = font.texture;\n\t\t\t\tif (texture !== null) {\n\n\t\t\t\t\tfor (t = 0, l = text.length; t < l; t++) {\n\n\t\t\t\t\t\tvar chr = font.measure(text[t]);\n\n\t\t\t\t\t\tvar x = x1 + margin - font.spacing;\n\t\t\t\t\t\tvar y = y1;\n\n\n\t\t\t\t\t\t_draw_ctx.call(ctx, x, y, text[t]);\n\n\n\t\t\t\t\t\tmargin += chr.realwidth + font.kerning;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * RENDERING API\n\t\t */\n\n\t\trenderEntity: function(entity, offsetX, offsetY) {\n\n\t\t\tif (typeof entity.render === 'function') {\n\n\t\t\t\tentity.render(\n\t\t\t\t\tthis,\n\t\t\t\t\toffsetX || 0,\n\t\t\t\t\toffsetY || 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.Jukebox":{"constructor":"lychee.Definition","arguments":["lychee.game.Jukebox"],"blob":{"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _refresh_channels = function(amount) {\n\n\t\tvar sounds = [];\n\n\t\tfor (var a = 0; a < amount; a++) {\n\t\t\tsounds.push(null);\n\t\t}\n\n\t\tthis.__sounds = sounds;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.channels = 8;\n\t\tthis.music    = true;\n\t\tthis.sound    = true;\n\n\t\tthis.__music  = null;\n\t\tthis.__sounds = [\n\t\t\tnull, null,\n\t\t\tnull, null,\n\t\t\tnull, null,\n\t\t\tnull, null\n\t\t];\n\n\n\t\tthis.setChannels(settings.channels);\n\t\tthis.setMusic(settings.music);\n\t\tthis.setSound(settings.sound);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tplay: function(track) {\n\n\t\t\tif (track instanceof Music && this.music === true) {\n\n\t\t\t\tvar music = this.__music;\n\t\t\t\tif (music !== null) {\n\t\t\t\t\tmusic.stop();\n\t\t\t\t}\n\n\n\t\t\t\tthis.__music = track;\n\t\t\t\tthis.__music.play();\n\n\n\t\t\t\treturn true;\n\n\t\t\t} else if (track instanceof Sound && this.sound === true) {\n\n\t\t\t\tvar sounds = this.__sounds;\n\t\t\t\tfor (var s = 0, sl = sounds.length; s < sl; s++) {\n\n\t\t\t\t\tvar sound = sounds[s];\n\t\t\t\t\tif (sound === null) {\n\n\t\t\t\t\t\tsounds[s] = track.clone();\n\t\t\t\t\t\tsounds[s].play();\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else if (sound.isIdle === true) {\n\n\t\t\t\t\t\tif (sound.url === track.url) {\n\t\t\t\t\t\t\tsound.play();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsounds[s] = track.clone();\n\t\t\t\t\t\t\tsounds[s].play();\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tstop: function(track) {\n\n\t\t\ttrack = (track instanceof Music || track instanceof Sound) ? track : null;\n\n\n\t\t\tvar found  = false;\n\t\t\tvar music  = this.__music;\n\t\t\tvar sounds = this.__sounds;\n\n\n\t\t\tvar s, sl, sound = null;\n\n\t\t\tif (track instanceof Music) {\n\n\t\t\t\tif (music === track) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tmusic.stop();\n\t\t\t\t}\n\n\n\t\t\t\tthis.__music = null;\n\n\t\t\t} else if (track instanceof Sound) {\n\n\t\t\t\tfor (s = 0, sl = sounds.length; s < sl; s++) {\n\n\t\t\t\t\tsound = sounds[s];\n\n\t\t\t\t\tif (sound !== null && sound.url === track.url && sound.isIdle === false) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tsound.stop();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if (track === null) {\n\n\t\t\t\tif (music !== null) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tmusic.stop();\n\t\t\t\t}\n\n\n\t\t\t\tfor (s = 0, sl = sounds.length; s < sl; s++) {\n\n\t\t\t\t\tsound = sounds[s];\n\n\t\t\t\t\tif (sound !== null && sound.isIdle === false) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tsound.stop();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\t\tsetChannels: function(channels) {\n\n\t\t\tchannels = typeof channels === 'number' ? channels : null;\n\n\n\t\t\tif (channels !== null) {\n\n\t\t\t\tthis.channels = channels;\n\n\t\t\t\t_refresh_channels.call(this, channels);\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetMusic: function(music) {\n\n\t\t\tif (music === true || music === false) {\n\n\t\t\t\tthis.music = music;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetSound: function(sound) {\n\n\t\t\tif (sound === true || sound === false) {\n\n\t\t\t\tthis.sound = sound;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.Loop":{"constructor":"lychee.Definition","arguments":["lychee.game.Loop"],"blob":{"includes":["lychee.event.Emitter"],"supports":"function (lychee, global) {\n\n\tif (typeof setInterval === 'function') {\n\t\treturn true;\n\t}\n\n\treturn false;\n\n}","exports":"function (lychee, global) {\n\n    var _instances = [];\n \tvar _id        = 0;\n\n\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _listeners = {\n\n\t\tinterval: function() {\n\n\t\t\tvar now = Date.now();\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\n\t\t\t\tvar instance = _instances[i];\n\t\t\t\tvar clock    = now - instance.__start;\n\n\t\t\t\t_update_loop.call(instance, clock);\n\t\t\t\t_render_loop.call(instance, clock);\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\t(function(delta) {\n\n\t\tvar interval = typeof global.setInterval === 'function';\n\t\tif (interval === true) {\n\t\t\tglobal.setInterval(_listeners.interval, delta);\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (interval) methods.push('setInterval');\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.game.Loop: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.log('lychee.game.Loop: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\t})((1000 / 60) | 0);\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _update_loop;\n\n\tif (lychee.debug === true) {\n\n\t\t_update_loop = function(clock) {\n\n\t\t\tif (this.__state !== 1) return;\n\n\n\t\t\tvar delta = clock - this.__updateclock;\n\t\t\tif (delta >= this.__updatedelay) {\n\n\t\t\t\tthis.trigger('update', [ clock, delta ]);\n\n\n\t\t\t\tfor (var iid in this.__intervals) {\n\n\t\t\t\t\tvar interval = this.__intervals[iid];\n\n\t\t\t\t\tif (clock >= interval.clock) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tinterval.callback.call(\n\t\t\t\t\t\t\t\tinterval.scope,\n\t\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\t\tclock - interval.clock,\n\t\t\t\t\t\t\t\tinterval.step++\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\t\tlychee.Debugger.report(null, err, null);\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tinterval.clock = clock + interval.delta;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var tid in this.__timeouts) {\n\n\t\t\t\t\tvar timeout = this.__timeouts[tid];\n\t\t\t\t\tif (clock >= timeout.clock) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\ttimeout.callback.call(\n\t\t\t\t\t\t\t\ttimeout.scope,\n\t\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\t\tclock - timeout.clock\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t} catch(err) {\n\t\t\t\t\t\t\tlychee.Debugger.report(null, err, null);\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tdelete this.__timeouts[tid];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tthis.__updateclock = clock;\n\n\t\t\t}\n\n\t\t};\n\n\n\t} else {\n\n\t\t_update_loop = function(clock) {\n\n\t\t\tif (this.__state !== 1) return;\n\n\n\t\t\tvar delta = clock - this.__updateclock;\n\t\t\tif (delta >= this.__updatedelay) {\n\n\t\t\t\tthis.trigger('update', [ clock, delta ]);\n\n\n\t\t\t\tfor (var iid in this.__intervals) {\n\n\t\t\t\t\tvar interval = this.__intervals[iid];\n\n\t\t\t\t\tif (clock >= interval.clock) {\n\n\t\t\t\t\t\tinterval.callback.call(\n\t\t\t\t\t\t\tinterval.scope,\n\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\tclock - interval.clock,\n\t\t\t\t\t\t\tinterval.step++\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tinterval.clock = clock + interval.delta;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var tid in this.__timeouts) {\n\n\t\t\t\t\tvar timeout = this.__timeouts[tid];\n\t\t\t\t\tif (clock >= timeout.clock) {\n\n\t\t\t\t\t\ttimeout.callback.call(\n\t\t\t\t\t\t\ttimeout.scope,\n\t\t\t\t\t\t\tclock,\n\t\t\t\t\t\t\tclock - timeout.clock\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdelete this.__timeouts[tid];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tthis.__updateclock = clock;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\n\tvar _render_loop = function(clock) {\n\n\t\tif (this.__state !== 1) return;\n\n\n\t\tvar delta = clock - this.__renderclock;\n\t\tif (delta >= this.__renderdelay) {\n\n\t\t\tthis.trigger('render', [ clock, delta ]);\n\n\n\t\t\tthis.__renderclock = clock;\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.update = 40;\n\t\tthis.render = 40;\n\n\t\tthis.__timeouts  = {};\n\t\tthis.__intervals = {};\n\n\t\tthis.__pause       = 0;\n\t\tthis.__state       = 1;\n\t\tthis.__start       = Date.now();\n\t\tthis.__renderclock = 0;\n\t\tthis.__renderdelay = 1000 / this.update;\n\t\tthis.__updateclock = 0;\n\t\tthis.__updatedelay = 1000 / this.render;\n\n\n\t\tthis.setUpdate(settings.update);\n\t\tthis.setRender(settings.render);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\t_instances.push(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.update !== 40) settings.update = this.update;\n\t\t\tif (this.render !== 40) settings.render = this.render;\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Loop',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tstart: function() {\n\n\t\t\tthis.__state = 1;\n\t\t\tthis.__start = Date.now();\n\n\t\t},\n\n\t\tstop: function() {\n\n\t\t\tthis.__state = 0;\n\n\t\t},\n\n\t\tpause: function() {\n\n\t\t\tthis.__state = 0;\n\t\t\tthis.__pause = Date.now() - this.__start;\n\n\t\t},\n\n\t\tresume: function() {\n\n\t\t\tthis.__state = 1;\n\t\t\tthis.__start = Date.now() - this.__pause;\n\t\t\tthis.__pause = 0;\n\n\t\t},\n\n\t\tsetTimeout: function(delta, callback, scope) {\n\n\t\t\tdelta    = typeof delta === 'number'    ? delta    : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : global;\n\n\n\t\t\tif (delta === null || callback === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\n\t\t\tvar id = _id++;\n\n\t\t\tthis.__timeouts[id] = {\n\t\t\t\tclock:    this.__updateclock + delta,\n\t\t\t\tcallback: callback,\n\t\t\t\tscope:    scope\n\t\t\t};\n\n\n\t\t\treturn id;\n\n\t\t},\n\n\t\tremoveTimeout: function(id) {\n\n\t\t\tid = typeof id === 'number' ? id : null;\n\n\n\t\t\tif (id !== null && this.__timeouts[id] !== undefined) {\n\n\t\t\t\tdelete this.__timeouts[id];\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetInterval: function(delta, callback, scope) {\n\n\t\t\tdelta    = typeof delta === 'number'    ? delta    : null;\n\t\t\tcallback = callback instanceof Function ? callback : null;\n\t\t\tscope    = scope !== undefined          ? scope    : global;\n\n\n\t\t\tif (delta === null || callback === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\n\t\t\tvar id = _id++;\n\n\t\t\tthis.__intervals[id] = {\n\t\t\t\tclock:    this.__updateclock + delta,\n\t\t\t\tdelta:    delta,\n\t\t\t\tstep:     1,\n\t\t\t\tcallback: callback,\n\t\t\t\tscope:    scope\n\t\t\t};\n\n\n\t\t\treturn id;\n\n\t\t},\n\n\t\tremoveInterval: function(id) {\n\n\t\t\tid = typeof id === 'number' ? id : null;\n\n\n\t\t\tif (id !== null && this.__intervals[id] !== undefined) {\n\n\t\t\t\tdelete this.__intervals[id];\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetUpdate: function(update) {\n\n\t\t\tupdate = typeof update === 'number' ? update : null;\n\n\n\t\t\tif (update !== null && update > 0) {\n\n\t\t\t\tthis.update        = update;\n\t\t\t\tthis.__updatedelay = 1000 / update;\n\n\t\t\t\treturn true;\n\n\t\t\t} else if (update === 0) {\n\n\t\t\t\tthis.update        = update;\n\t\t\t\tthis.__updatedelay = Infinity;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetRender: function(render) {\n\n\t\t\trender = typeof render === 'number' ? render : null;\n\n\n\t\t\tif (render !== null && render > 0) {\n\n\t\t\t\tthis.render        = render;\n\t\t\t\tthis.__renderdelay = 1000 / render;\n\n\t\t\t\treturn true;\n\n\t\t\t} else if (render === 0) {\n\n\t\t\t\tthis.render        = render;\n\t\t\t\tthis.__renderdelay = Infinity;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.State":{"constructor":"lychee.Definition","arguments":["lychee.game.State"],"blob":{"requires":["lychee.game.Layer","lychee.game.Logic","lychee.ui.Layer"],"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _trace_entity_offset = function(entity, layer, offsetX, offsetY) {\n\n\t\tif (offsetX === undefined || offsetY === undefined) {\n\n\t\t\tthis.x  = 0;\n\t\t\tthis.y  = 0;\n\t\t\toffsetX = layer.position.x;\n\t\t\toffsetY = layer.position.y;\n\n\t\t}\n\n\n\t\tif (layer === entity) {\n\n\t\t\tthis.x = offsetX;\n\t\t\tthis.y = offsetY;\n\n\t\t\treturn true;\n\n\t\t} else if (layer.entities !== undefined) {\n\n\t\t\tvar entities = layer.entities;\n\t\t\tfor (var e = entities.length - 1; e >= 0; e--) {\n\n\t\t\t\tvar dx = layer.offset.x + entities[e].position.x;\n\t\t\t\tvar dy = layer.offset.y + entities[e].position.y;\n\n\n\t\t\t\tvar result = _trace_entity_offset.call(\n\t\t\t\t\tthis,\n\t\t\t\t\tentity,\n\t\t\t\t\tentities[e],\n\t\t\t\t\toffsetX + dx,\n\t\t\t\t\toffsetY + dy\n\t\t\t\t);\n\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(main) {\n\n\t\tthis.main     = main          || null;\n\t\tthis.client   = main.client   || null;\n\t\tthis.input    = main.input    || null;\n\t\tthis.jukebox  = main.jukebox  || null;\n\t\tthis.loop     = main.loop     || null;\n\t\tthis.renderer = main.renderer || null;\n\n\n\t\tthis.__layers  = {};\n\t\tthis.__logics  = [];\n\t\tthis.__focus   = null;\n\t\tthis.__touches = [\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } },\n\t\t\t{ entity: null, layer: null, offset: { x: 0, y: 0 } }\n\t\t];\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * STATE API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tif (blob.layers) {\n\n\t\t\t\tfor (var laid in blob.layers) {\n\t\t\t\t\tthis.setLayer(laid, lychee.deserialize(blob.layers[laid]));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (blob.logics) {\n\n\t\t\t\tfor (var l = 0, ll = blob.logics.length; b < bl; b++) {\n\t\t\t\t\tthis.addLogic(lychee.deserialize(blob.logics[l]));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = this.main !== null ? '#MAIN' : null;\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (Object.keys(this.__layers).length > 0) {\n\n\t\t\t\tblob.layers = {};\n\n\t\t\t\tfor (var lid in this.__layers) {\n\t\t\t\t\tblob.layers[lid] = lychee.serialize(this.__layers[lid]);\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (this.__logics.length > 0) {\n\n\t\t\t\tblob.logics = [];\n\n\t\t\t\tfor (var l = 0, ll = this.__logics.length; l < ll; l++) {\n\t\t\t\t\tblob.logics.push(lychee.serialize(this.__logics[l]));\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.State',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\t\tenter: function(data) {\n\n\t\t\tvar input = this.input;\n\t\t\tif (input !== null) {\n\t\t\t\tinput.bind('key',   this.processKey,   this);\n\t\t\t\tinput.bind('touch', this.processTouch, this);\n\t\t\t\tinput.bind('swipe', this.processSwipe, this);\n\t\t\t}\n\n\t\t\tvar logics = this.__logics;\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\t\t\t\tlogics[l].enter(data);\n\t\t\t}\n\n\t\t},\n\n\t\tleave: function() {\n\n\t\t\tvar focus = this.__focus;\n\t\t\tif (focus !== null) {\n\t\t\t\tfocus.trigger('blur');\n\t\t\t}\n\n\n\t\t\tfor (var t = 0, tl = this.__touches.length; t < tl; t++) {\n\n\t\t\t\tvar touch = this.__touches[t];\n\t\t\t\tif (touch.entity !== null) {\n\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tthis.__focus = null;\n\n\n\t\t\tvar input = this.input;\n\t\t\tif (input !== null) {\n\t\t\t\tinput.unbind('swipe', this.processSwipe, this);\n\t\t\t\tinput.unbind('touch', this.processTouch, this);\n\t\t\t\tinput.unbind('key',   this.processKey,   this);\n\t\t\t}\n\n\t\t\tvar logics = this.__logics;\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\t\t\t\tlogics[l].leave();\n\t\t\t}\n\n\t\t},\n\n\t\tshow: function() {\n\n\t\t},\n\n\t\treshape: function() {\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tvar position = {\n\t\t\t\t\tx: 1/2 * renderer.width,\n\t\t\t\t\ty: 1/2 * renderer.height\n\t\t\t\t};\n\n\t\t\t\tfor (var id in this.__layers) {\n\t\t\t\t\tthis.__layers[id].setPosition(position);\n\t\t\t\t\tthis.__layers[id].reshape();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\thide: function() {\n\n\t\t},\n\n\t\trender: function(clock, delta, custom) {\n\n\t\t\tcustom = custom === true;\n\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tif (custom === false) {\n\t\t\t\t\trenderer.clear();\n\t\t\t\t}\n\n\n\t\t\t\tfor (var id in this.__layers) {\n\n\t\t\t\t\tvar layer = this.__layers[id];\n\t\t\t\t\tif (layer.visible === false) continue;\n\n\t\t\t\t\tlayer.render(\n\t\t\t\t\t\trenderer,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\n\t\t\t\tif (custom === false) {\n\t\t\t\t\trenderer.flush();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tfor (var id in this.__layers) {\n\n\t\t\t\tvar layer = this.__layers[id];\n\t\t\t\tif (layer.visible === false) continue;\n\n\t\t\t\tlayer.update(clock, delta);\n\n\t\t\t}\n\n\n\t\t\tvar logics = this.__logics;\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\t\t\t\tlogics[l].update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * LAYER API\n\t\t */\n\n\t\tsetLayer: function(id, layer) {\n\n\t\t\tid    = typeof id === 'string'                                                                       ? id    : null;\n\t\t\tlayer = (lychee.interfaceof(lychee.game.Layer, layer) || lychee.interfaceof(lychee.ui.Layer, layer)) ? layer : null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tif (layer !== null) {\n\n\t\t\t\t\tthis.__layers[id] = layer;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetLayer: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__layers[id] !== undefined) {\n\t\t\t\treturn this.__layers[id];\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tqueryLayer: function(id, query) {\n\n\t\t\tid    = typeof id === 'string'    ? id    : null;\n\t\t\tquery = typeof query === 'string' ? query : null;\n\n\n\t\t\tif (id !== null && query !== null) {\n\n\t\t\t\tvar layer = this.getLayer(id);\n\t\t\t\tif (layer !== null) {\n\n\t\t\t\t\tvar entity = layer;\n\t\t\t\t\tvar ids    = query.split(' > ');\n\n\t\t\t\t\tfor (var i = 0, il = ids.length; i < il; i++) {\n\n\t\t\t\t\t\tentity = entity.getEntity(ids[i]);\n\n\t\t\t\t\t\tif (entity === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn entity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tremoveLayer: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__layers[id] !== undefined) {\n\n\t\t\t\tdelete this.__layers[id];\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\t/*\n\t\t * LOGIC API\n\t\t */\n\n\t\taddLogic: function(logic) {\n\n\t\t\tlogic = lychee.interfaceof(lychee.game.Logic, logic) ? logic : null;\n\n\n\t\t\tif (logic !== null) {\n\n\t\t\t\tvar index = this.__logics.indexOf(logic);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.__logics.push(logic);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveLogic: function(logic) {\n\n\t\t\tlogic = lychee.interfaceof(lychee.game.Logic, logic) ? logic : null;\n\n\n\t\t\tif (logic !== null) {\n\n\t\t\t\tvar index = this.__logics.indexOf(logic);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.__logics.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetLogics: function(logics) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (logics instanceof Array) {\n\n\t\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\n\t\t\t\t\tvar result = this.addLogic(logics[l]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveLogics: function() {\n\n\t\t\tvar logics = this.__logics;\n\n\t\t\tfor (var l = 0, ll = logics.length; l < ll; l++) {\n\n\t\t\t\tthis.removeLogic(logics[l]);\n\n\t\t\t\tll--;\n\t\t\t\tl--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * EVENT API\n\t\t */\n\n\t\tprocessKey: function(key, name, delta) {\n\n\t\t\tvar focus = this.__focus;\n\t\t\tif (focus !== null) {\n\n\t\t\t\tvar result = focus.trigger('key', [ key, name, delta ]);\n\t\t\t\tif (result === true && key === 'return' && focus.state === 'default') {\n\t\t\t\t\tthis.__focus = null;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tprocessTouch: function(id, position, delta) {\n\n\t\t\tvar args = [ id, {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0\n\t\t\t}, delta ];\n\n\n\t\t\tvar x = position.x;\n\t\t\tvar y = position.y;\n\n\n\t\t\tvar renderer = this.renderer;\n\t\t\tif (renderer !== null) {\n\n\t\t\t\tx -= renderer.offset.x;\n\t\t\t\ty -= renderer.offset.y;\n\n\t\t\t}\n\n\n\t\t\tvar touch_layer  = null;\n\t\t\tvar touch_entity = null;\n\n\t\t\tfor (var lid in this.__layers) {\n\n\t\t\t\tvar layer = this.__layers[lid];\n\t\t\t\tif (layer.visible === false) continue;\n\n\t\t\t\tif (lychee.interfaceof(lychee.ui.Layer, layer)) {\n\n\t\t\t\t\targs[1].x = x - layer.position.x;\n\t\t\t\t\targs[1].y = y - layer.position.y;\n\n\n\t\t\t\t\tvar result = layer.trigger('touch', args);\n\t\t\t\t\tif (result !== true && result !== false && result !== null) {\n\n\t\t\t\t\t\ttouch_entity = result;\n\t\t\t\t\t\ttouch_layer  = layer;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tvar old_focus = this.__focus;\n\t\t\tvar new_focus = touch_entity;\n\n\t\t\t// 1. Reset Touch trace data if no Entity was touched\n\t\t\tif (new_focus === null) {\n\t\t\t\tthis.__touches[id].entity = null;\n\t\t\t\tthis.__touches[id].layer  = null;\n\t\t\t}\n\n\n\t\t\t// 2. Change Focus State Interaction\n\t\t\tif (new_focus !== old_focus) {\n\n\t\t\t\tif (old_focus !== null) {\n\n\t\t\t\t\tif (old_focus.state !== 'default') {\n\t\t\t\t\t\told_focus.trigger('blur');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (new_focus !== null) {\n\n\t\t\t\t\tif (new_focus.state === 'default') {\n\t\t\t\t\t\tnew_focus.trigger('focus');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tthis.__focus = new_focus;\n\n\t\t\t}\n\n\n\t\t\t// 3. Prepare UI Swipe event\n\t\t\tif (touch_entity !== null) {\n\n\t\t\t\tvar touch = this.__touches[id];\n\n\t\t\t\ttouch.entity   = new_focus;\n\t\t\t\ttouch.layer    = touch_layer;\n\n\n\t\t\t\t// TODO: Fix intelligent reshape() calls for resizing entities on touch events\n\t\t\t\tthis.loop.setTimeout(300, function() {\n\t\t\t\t\tthis.reshape();\n\t\t\t\t}, touch.layer);\n\n\n\t\t\t\t_trace_entity_offset.call(\n\t\t\t\t\ttouch.offset,\n\t\t\t\t\ttouch.entity,\n\t\t\t\t\ttouch.layer\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\t\tprocessSwipe: function(id, type, position, delta, swipe) {\n\n\t\t\tvar touch = this.__touches[id];\n\t\t\tif (touch.entity !== null) {\n\n\t\t\t\tif (touch.layer.visible === false) return;\n\n\n\t\t\t\tvar args   = [ id, type, position, delta, swipe ];\n\t\t\t\tvar result = false;\n\n\t\t\t\tvar renderer = this.renderer;\n\t\t\t\tif (renderer !== null) {\n\n\t\t\t\t\targs[2].x -= renderer.offset.x;\n\t\t\t\t\targs[2].y -= renderer.offset.y;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (type === 'start') {\n\n\t\t\t\t\t_trace_entity_offset.call(\n\t\t\t\t\t\ttouch.offset,\n\t\t\t\t\t\ttouch.entity,\n\t\t\t\t\t\ttouch.layer\n\t\t\t\t\t);\n\n\n\t\t\t\t\targs[2].x -= touch.offset.x;\n\t\t\t\t\targs[2].y -= touch.offset.y;\n\t\t\t\t\tresult     = touch.entity.trigger('swipe', args);\n\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t\t}\n\n\t\t\t\t} else if (type === 'move') {\n\n\t\t\t\t\targs[2].x -= touch.offset.x;\n\t\t\t\t\targs[2].y -= touch.offset.y;\n\t\t\t\t\tresult     = touch.entity.trigger('swipe', args);\n\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t\t}\n\n\t\t\t\t} else if (type === 'end') {\n\n\t\t\t\t\targs[2].x -= touch.offset.x;\n\t\t\t\t\targs[2].y -= touch.offset.y;\n\t\t\t\t\tresult     = touch.entity.trigger('swipe', args);\n\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\ttouch.entity = null;\n\t\t\t\t\t\ttouch.layer  = null;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.Viewport":{"constructor":"lychee.Definition","arguments":["lychee.Viewport"],"blob":{"tags":{"platform":"nodejs"},"includes":["lychee.event.Emitter"],"supports":"function (lychee, global) {\n\n\tif (typeof process !== 'undefined') {\n\n\t\tif (typeof process.stdout === 'object' && typeof process.stdout.on === 'function') {\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\treturn false;\n\n}","exports":"function (lychee, global) {\n\n\t/*\n\t * EVENTS\n\t */\n\n\tvar _instances = [];\n\n\tvar _listeners = {\n\n\t\tresize: function() {\n\n\t\t\tfor (var i = 0, l = _instances.length; i < l; i++) {\n\t\t\t\t_process_reshape.call(_instances[i], process.stdout.columns, process.stdout.rows);\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * FEATURE DETECTION\n\t */\n\n\t(function() {\n\n\t\tvar resize = true;\n\t\tif (resize === true) {\n\t\t\tprocess.stdout.on('resize', _listeners.resize);\n\t\t}\n\n\n\t\tif (lychee.debug === true) {\n\n\t\t\tvar methods = [];\n\n\t\t\tif (resize) methods.push('Resize');\n\n\t\t\tif (methods.length === 0) {\n\t\t\t\tconsole.error('lychee.Viewport: Supported methods are NONE');\n\t\t\t} else {\n\t\t\t\tconsole.info('lychee.Viewport: Supported methods are ' + methods.join(', '));\n\t\t\t}\n\n\t\t}\n\n\t})();\n\n\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _process_reshape = function(width, height) {\n\n\t\tif (width === this.width && height === this.height) {\n\t\t\treturn false;\n\t\t}\n\n\n\t\tthis.width  = width;\n\t\tthis.height = height;\n\n\n\n\t\tvar orientation = null;\n\t\tvar rotation    = null;\n\n\t\tif (width > height) {\n\n\t\t\torientation = 'landscape';\n\t\t\trotation    = 'landscape';\n\n\t\t} else {\n\n\t\t\torientation = 'landscape';\n\t\t\trotation    = 'landscape';\n\n\t\t}\n\n\n\n\t\tvar handled = false;\n\n\t\thandled = this.trigger('reshape', [ orientation, rotation ]) || handled;\n\n\n\t\tif (handled === true) {\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tthis.__history.reshape.push([ Date.now(), orientation, rotation ]);\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn handled;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.fullscreen = false;\n\t\tthis.width      = process.stdout.columns;\n\t\tthis.height     = process.stdout.rows;\n\n\t\tthis.__orientation = 0; // Unsupported\n\t\tthis.__history     = {\n\t\t\tshow:    [],\n\t\t\thide:    [],\n\t\t\treshape: []\n\t\t};\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\t_instances.push(this);\n\n\n\t\tthis.setFullscreen(settings.fullscreen);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tdestroy: function() {\n\n\t\t\tvar found = false;\n\n\t\t\tfor (var i = 0, il = _instances.length; i < il; i++) {\n\n\t\t\t\tif (_instances[i] === this) {\n\t\t\t\t\t_instances.splice(i, 1);\n\t\t\t\t\tfound = true;\n\t\t\t\t\til--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.unbind();\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.fullscreen !== false) settings.fullscreen = this.fullscreen;\n\n\n\t\t\tif (this.__history.show.length > 0 || this.__history.hide.length > 0 || this.__history.reshape.length > 0) {\n\n\t\t\t\tblob.history = {};\n\n\t\t\t\tif (this.__history.show.length > 0) {\n\n\t\t\t\t\tblob.history.show = [];\n\n\t\t\t\t\tfor (var s = 0, sl = this.__history.show.length; s < sl; s++) {\n\t\t\t\t\t\tblob.history.show.push(this.__history.show[s]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.hide.length > 0) {\n\n\t\t\t\t\tblob.history.hide = [];\n\n\t\t\t\t\tfor (var h = 0, hl = this.__history.hide.length; h < hl; h++) {\n\t\t\t\t\t\tblob.history.hide.push(this.__history.hide[h]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (this.__history.reshape.length > 0) {\n\n\t\t\t\t\tblob.history.reshape = [];\n\n\t\t\t\t\tfor (var r = 0, rl = this.__history.reshape.length; r < rl; r++) {\n\t\t\t\t\t\tblob.history.reshape.push(this.__history.reshape[r]);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.Viewport',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tsetFullscreen: function(fullscreen) {\n\t\t\treturn false;\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.net.Client":{"constructor":"lychee.Definition","arguments":["lychee.net.Client"],"blob":{"tags":{"platform":"nodejs"},"includes":["lychee.event.Emitter"],"supports":"function (lychee, global) {\n\n\tif (typeof process !== 'undefined') {\n\t\treturn true;\n\t}\n\n\n\treturn false;\n\n}","exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _receive_handler = function(blob, isBinary) {\n\n\t\tvar data = null;\n\t\ttry {\n\t\t\tdata = this.__decoder(blob);\n\t\t} catch(e) {\n\t\t\t// Unsupported data encoding\n\t\t\treturn false;\n\t\t}\n\n\n\t\tif (data instanceof Object && typeof data._serviceId === 'string') {\n\n\t\t\tvar service = _get_service_by_id.call(this, data._serviceId);\n\t\t\tvar event   = data._serviceEvent  || null;\n\t\t\tvar method  = data._serviceMethod || null;\n\n\n\t\t\tif (method !== null) {\n\n\t\t\t\tif (method.charAt(0) === '@') {\n\n\t\t\t\t\tif (method === '@plug') {\n\t\t\t\t\t\t_plug_service.call(this,   data._serviceId, service);\n\t\t\t\t\t} else if (method === '@unplug') {\n\t\t\t\t\t\t_unplug_service.call(this, data._serviceId, service);\n\t\t\t\t\t}\n\n\t\t\t\t} else if (service !== null && typeof service[method] === 'function') {\n\n\t\t\t\t\t// Remove data frame service header\n\t\t\t\t\tdelete data._serviceId;\n\t\t\t\t\tdelete data._serviceMethod;\n\n\t\t\t\t\tservice[method](data);\n\n\t\t\t\t}\n\n\t\t\t} else if (event !== null) {\n\n\t\t\t\tif (service !== null && typeof service.trigger === 'function') {\n\n\t\t\t\t\t// Remove data frame service header\n\t\t\t\t\tdelete data._serviceId;\n\t\t\t\t\tdelete data._serviceEvent;\n\n\t\t\t\t\tservice.trigger(event, [ data ]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.trigger('receive', [ data ]);\n\n\t\t}\n\n\n\t\treturn true;\n\n\t};\n\n\tvar _get_service_by_id = function(id) {\n\n\t\tvar service;\n\n\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\tservice = this.__services.waiting[w];\n\t\t\tif (service.id === id) {\n\t\t\t\treturn service;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\tservice = this.__services.active[a];\n\t\t\tif (service.id === id) {\n\t\t\t\treturn service;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn null;\n\n\t};\n\n\tvar _is_service_waiting = function(service) {\n\n\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\tif (this.__services.waiting[w] === service) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _is_service_active = function(service) {\n\n\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\tif (this.__services.active[a] === service) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _plug_service = function(id, service) {\n\n\t\tid = typeof id === 'string' ? id : null;\n\n\t\tif (id === null || service === null) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar found = false;\n\n\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\tif (this.__services.waiting[w] === service) {\n\t\t\t\tthis.__services.waiting.splice(w, 1);\n\t\t\t\tfound = true;\n\t\t\t\twl--;\n\t\t\t\tw--;\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (found === true) {\n\n\t\t\tthis.__services.active.push(service);\n\n\t\t\tservice.trigger('plug', []);\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tconsole.log('lychee.net.Client: Remote plugged in Service (' + id + ')');\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar _unplug_service = function(id, service) {\n\n\t\tid = typeof id === 'string' ? id : null;\n\n\t\tif (id === null || service === null) {\n\t\t\treturn;\n\t\t}\n\n\n\t\tvar found = false;\n\n\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\tif (this.__services.active[a] === service) {\n\t\t\t\tthis.__services.active.splice(a, 1);\n\t\t\t\tfound = true;\n\t\t\t\tal--;\n\t\t\t\ta--;\n\t\t\t}\n\n\t\t}\n\n\n\t\tif (found === true) {\n\n\t\t\tservice.trigger('unplug', []);\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tconsole.log('lychee.net.Client: Remote unplugged Service (' + id + ')');\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar _cleanup_services = function() {\n\n\t\tvar services = this.__services.active;\n\n\t\tfor (var s = 0; s < services.length; s++) {\n\t\t\tservices[s].trigger('unplug', []);\n\t\t}\n\n\n\t\tthis.__services.active  = [];\n\t\tthis.__services.waiting = [];\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function() {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.port      = 1337;\n\t\tthis.host      = 'localhost';\n\t\tthis.reconnect = 0;\n\n\n\t\tthis.__encoder = settings.encoder instanceof Function ? settings.encoder : JSON.stringify;\n\t\tthis.__decoder = settings.decoder instanceof Function ? settings.decoder : JSON.parse;\n\t\tthis.__socket  = null;\n\t\tthis.__services  = {\n\t\t\twaiting: [], // Waiting Services need to be verified from Remote\n\t\t\tactive:  []  // Active Services for allowed interaction\n\t\t};\n\n\t\tthis.__isBinary  = false;\n\t\tthis.__isRunning = false;\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\tlisten: function(port, host) {\n\n\t\t\tif (this.__socket !== null) return false;\n\n\n\t\t\tthis.port = typeof port === 'number' ? port : this.port;\n\t\t\tthis.host = typeof host === 'string' ? host : this.host;\n\n\n\t\t\tif (this.__isRunning === true) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tif (lychee.debug === true) {\n\t\t\t\tconsole.log('lychee.net.Client: Listening on ' + this.host + ':' + this.port);\n\t\t\t}\n\n\n\t\t\tvar url = 'ws://' + this.host + ':' + this.port;\n\n\t\t\t// TODO: Create this.__socket instance and bind close and message events\n\n\t\t},\n\n\t\tsend: function(data, service) {\n\n\t\t\tdata    = data instanceof Object    ? data    : null;\n\t\t\tservice = service instanceof Object ? service : null;\n\n\n\t\t\tif (data === null || this.__isRunning === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tif (service !== null) {\n\n\t\t\t\tif (typeof service.id     === 'string') data._serviceId     = service.id;\n\t\t\t\tif (typeof service.event  === 'string') data._serviceEvent  = service.event;\n\t\t\t\tif (typeof service.method === 'string') data._serviceMethod = service.method;\n\n\t\t\t}\n\n\n\t\t\tvar blob = this.__encoder(data);\n\t\t\tif (this.__isBinary === true) {\n\n\t\t\t\tvar bl    = blob.length;\n\t\t\t\tvar bytes = new Uint8Array(bl);\n\n\t\t\t\tfor (var b = 0; b < bl; b++) {\n\t\t\t\t\tbytes[b] = blob.charCodeAt(b);\n\t\t\t\t}\n\n\t\t\t\tblob = bytes.buffer;\n\n\t\t\t}\n\n\n\t\t\t// TODO: Send data via this.__socket to server\n\t\t\t// this.__socket.send(blob);\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tconnect: function() {\n\n\t\t\tif (this.__isRunning === false) {\n\t\t\t\treturn this.listen(this.port, this.host);\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tdisconnect: function() {\n\n\t\t\tif (this.__isRunning === true) {\n\n\t\t\t\t// TODO: Close this.__socket connection\n\t\t\t\t// this.__socket.close();\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetReconnect: function(reconnect) {\n\n\t\t\treconnect = typeof reconnect === 'number' ? (reconnect | 0) : null;\n\n\n\t\t\tif (reconnect !== null) {\n\n\t\t\t\tthis.reconnect = reconnect;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\taddService: function(service) {\n\n\t\t\tservice = lychee.interfaceof(lychee.net.Service, service) ? service : null;\n\n\n\t\t\tif (service !== null) {\n\n\t\t\t\tif (_is_service_waiting.call(this, service) === false && _is_service_active.call(this, service) === false) {\n\n\t\t\t\t\tthis.__services.waiting.push(service);\n\n\t\t\t\t\t// Please, Remote, plug Service! PING\n\t\t\t\t\tthis.send({}, {\n\t\t\t\t\t\tid:     service.id,\n\t\t\t\t\t\tmethod: '@plug'\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetService: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tfor (var w = 0, wl = this.__services.waiting.length; w < wl; w++) {\n\n\t\t\t\t\tvar wservice = this.__services.waiting[w];\n\t\t\t\t\tif (wservice.id === id) {\n\t\t\t\t\t\treturn wservice;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor (var a = 0, al = this.__services.active.length; a < al; a++) {\n\n\t\t\t\t\tvar aservice = this.__services.active[a];\n\t\t\t\t\tif (aservice.id === id) {\n\t\t\t\t\t\treturn aservice;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn null;\n\n\t\t},\n\n\t\tremoveService: function(service) {\n\n\t\t\tservice = lychee.interfaceof(lychee.net.Service, service) ? service : null;\n\n\n\t\t\tif (service !== null) {\n\n\t\t\t\tif (_is_service_waiting.call(this, service) === true || _is_service_active.call(this, service) === true) {\n\n\t\t\t\t\t// Please, Remote, unplug Service! PING\n\t\t\t\t\tthis.send({}, {\n\t\t\t\t\t\tid:     service.id,\n\t\t\t\t\t\tmethod: '@unplug'\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.Layer":{"constructor":"lychee.Definition","arguments":["lychee.game.Layer"],"blob":{"requires":["lychee.game.Entity"],"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _validate_entity = function(entity) {\n\n\t\tif (entity instanceof Object) {\n\n\t\t\tif (typeof entity.update === 'function' && typeof entity.render === 'function' && typeof entity.shape === 'number') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _SHAPE_rectangle = 2;\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.width  = 0;\n\t\tthis.height = 0;\n\n\t\tthis.effects  = [];\n\t\tthis.entities = [];\n\t\tthis.offset   = { x: 0, y: 0 };\n\t\tthis.position = { x: 0, y: 0 };\n\t\tthis.shape    = _SHAPE_rectangle;\n\t\tthis.visible  = true;\n\n\t\tthis.__map     = {};\n\t\tthis.__reshape = true;\n\n\n\t\tthis.setEntities(settings.entities);\n\t\tthis.setOffset(settings.offset);\n\t\tthis.setPosition(settings.position);\n\t\tthis.setReshape(settings.reshape);\n\t\tthis.setVisible(settings.visible);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tvar entities = [];\n\t\t\tfor (var be = 0, bel = blob.entities.length; be < bel; be++) {\n\t\t\t\tentities.push(lychee.deserialize(blob.entities[be]));\n\t\t\t}\n\n\t\t\tvar map = {};\n\t\t\tfor (var bid in blob.map) {\n\n\t\t\t\tvar index = blob.map[bid];\n\t\t\t\tif (typeof index === 'number') {\n\t\t\t\t\tmap[bid] = index;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tvar id = null;\n\t\t\t\tfor (var mid in map) {\n\n\t\t\t\t\tif (map[mid] === e) {\n\t\t\t\t\t\tid = mid;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (id !== null) {\n\t\t\t\t\tthis.setEntity(id, entities[e]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.addEntity(entities[e]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.offset.x !== 0 || this.offset.y !== 0 || this.offset.z !== 0) {\n\n\t\t\t\tsettings.offset = {};\n\n\t\t\t\tif (this.offset.x !== 0) settings.offset.x = this.offset.x;\n\t\t\t\tif (this.offset.y !== 0) settings.offset.y = this.offset.y;\n\t\t\t\tif (this.offset.z !== 0) settings.offset.z = this.offset.z;\n\n\t\t\t}\n\n\t\t\tif (this.__reshape !== true) settings.reshape = this.__reshape;\n\t\t\tif (this.visible !== true)   settings.visible = this.visible;\n\n\n\t\t\tvar entities = [];\n\n\t\t\tif (this.entities.length > 0) {\n\n\t\t\t\tblob.entities = [];\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\n\t\t\t\t\tblob.entities.push(lychee.serialize(entity));\n\t\t\t\t\tentities.push(entity);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (Object.keys(this.__map).length > 0) {\n\n\t\t\t\tblob.map = {};\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tvar index = entities.indexOf(this.__map[id]);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tblob.map[id] = index;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Layer',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\t\trender: function(renderer, offsetX, offsetY) {\n\n\t\t\tif (this.visible === false) return;\n\n\t\t\tvar position = this.position;\n\t\t\tvar offset   = this.offset;\n\n\n\t\t\tvar ox = position.x + offsetX + offset.x;\n\t\t\tvar oy = position.y + offsetY + offset.y;\n\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tentities[e].render(\n\t\t\t\t\trenderer,\n\t\t\t\t\tox,\n\t\t\t\t\toy\n\t\t\t\t);\n\n\t\t\t}\n\n\n\t\t\tif (lychee.debug === true) {\n\n\t\t\t\tox = position.x + offsetX;\n\t\t\t\toy = position.y + offsetY;\n\n\n\t\t\t\tvar hwidth   = this.width  / 2;\n\t\t\t\tvar hheight  = this.height / 2;\n\n\n\t\t\t\trenderer.drawBox(\n\t\t\t\t\tox - hwidth,\n\t\t\t\t\toy - hheight,\n\t\t\t\t\tox + hwidth,\n\t\t\t\t\toy + hheight,\n\t\t\t\t\t'#ffff00',\n\t\t\t\t\tfalse,\n\t\t\t\t\t1\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var en = 0, enl = entities.length; en < enl; en++) {\n\t\t\t\tentities[en].update(clock, delta);\n\t\t\t}\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var ef = 0, efl = this.effects.length; ef < efl; ef++) {\n\n\t\t\t\tvar effect = this.effects[ef];\n\t\t\t\tif (effect.update(this, clock, delta) === false) {\n\t\t\t\t\tthis.removeEffect(effect);\n\t\t\t\t\tefl--;\n\t\t\t\t\tef--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\treshape: function() {\n\n\t\t\tif (this.__reshape === true) {\n\n\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\tvar hheight = this.height / 2;\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\tvar boundx = Math.abs(entity.position.x + this.offset.x);\n\t\t\t\t\tvar boundy = Math.abs(entity.position.y + this.offset.y);\n\n\t\t\t\t\tif (entity.shape === lychee.game.Entity.SHAPE.circle) {\n\t\t\t\t\t\tboundx += entity.radius;\n\t\t\t\t\t\tboundy += entity.radius;\n\t\t\t\t\t} else if (entity.shape === lychee.game.Entity.SHAPE.rectangle) {\n\t\t\t\t\t\tboundx += entity.width  / 2;\n\t\t\t\t\t\tboundy += entity.height / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\thwidth  = Math.max(hwidth,  boundx);\n\t\t\t\t\thheight = Math.max(hheight, boundy);\n\n\t\t\t\t}\n\n\t\t\t\tthis.width  = hwidth  * 2;\n\t\t\t\tthis.height = hheight * 2;\n\n\t\t\t}\n\n\t\t},\n\n\t\taddEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.effects.push(effect);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.effects.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffects: function() {\n\n\t\t\tvar effects = this.effects;\n\n\t\t\tfor (var e = 0, el = effects.length; e < el; e++) {\n\n\t\t\t\teffects[e].update(this, Infinity, 0);\n\t\t\t\tthis.removeEffect(effects[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\taddEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar index = this.entities.indexOf(entity);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.entities.push(entity);\n\t\t\t\t\tthis.reshape();\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntity: function(id, entity) {\n\n\t\t\tid     = typeof id === 'string'            ? id     : null;\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (id !== null && entity !== null && this.__map[id] === undefined) {\n\n\t\t\t\tthis.__map[id] = entity;\n\n\t\t\t\tvar result = this.addEntity(entity);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetEntity: function(id, position) {\n\n\t\t\tid        = typeof id === 'string'    ? id       : null;\n\t\t\tposition = position instanceof Object ? position : null;\n\n\n\t\t\tvar found = null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tif (this.__map[id] !== undefined) {\n\t\t\t\t\tfound = this.__map[id];\n\t\t\t\t}\n\n\t\t\t} else if (position !== null) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tfor (var e = this.entities.length - 1; e >= 0; e--) {\n\n\t\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\t\tif (entity.isAtPosition(position) === true) {\n\t\t\t\t\t\t\tfound = entity;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\t\tremoveEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar found = false;\n\n\t\t\t\tvar index = this.entities.indexOf(entity);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.entities.splice(index, 1);\n\t\t\t\t\tfound = true;\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tif (this.__map[id] === entity) {\n\n\t\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t\t\tfound = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (found === true) {\n\t\t\t\t\tthis.reshape();\n\t\t\t\t}\n\n\n\t\t\t\treturn found;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntities: function(entities) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (entities instanceof Array) {\n\n\t\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\t\tvar result = this.addEntity(entities[e]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveEntities: function() {\n\n\t\t\tvar entities = this.entities;\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tthis.removeEntity(entities[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetOffset: function(offset) {\n\n\t\t\tif (offset instanceof Object) {\n\n\t\t\t\tthis.offset.x = typeof offset.x === 'number' ? offset.x : this.offset.x;\n\t\t\t\tthis.offset.y = typeof offset.y === 'number' ? offset.y : this.offset.y;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tthis.position.x = typeof position.x === 'number' ? position.x : this.position.x;\n\t\t\t\tthis.position.y = typeof position.y === 'number' ? position.y : this.position.y;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetReshape: function(reshape) {\n\n\t\t\tif (reshape === true || reshape === false) {\n\n\t\t\t\tthis.__reshape = reshape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVisible: function(visible) {\n\n\t\t\tif (visible === true || visible === false) {\n\n\t\t\t\tthis.visible = visible;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.Logic":{"constructor":"lychee.Definition","arguments":["lychee.game.Logic"],"blob":{"requires":["lychee.game.Entity","lychee.game.Layer","lychee.game.Physic"],"exports":"function (lychee, global, attachments) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _project_layer = function(layer) {\n\n\t\tvar projection = this.projection;\n\t\tvar entities   = layer.entities;\n\n\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\t\t\tthis.projectPosition(entities[e].position, true);\n\t\t}\n\n\t};\n\n\tvar _unproject_layer = function(layer) {\n\n\t\tvar projection = this.projection;\n\t\tvar entities   = layer.entities;\n\n\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\t\t\tthis.unprojectPosition(entities[e].position, true);\n\t\t}\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.physic     = null;\n\t\tthis.projection = Class.PROJECTION.pixel;\n\t\tthis.tile       = {\n\t\t\twidth:  1,\n\t\t\theight: 1,\n\t\t\tdepth:  1\n\t\t};\n\n\t\tthis.__layers   = [];\n\n\n\t\tthis.setPhysic(settings.physic);\n\t\tthis.setProjection(settings.projection);\n\t\tthis.setTile(settings.tile);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.PROJECTION = {\n\t\tpixel:    0,\n\t\ttile:     1,\n\t\tisometry: 2\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\t// TODO: Deserialize layer query paths\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\t\t\tvar blob     = {};\n\n\n\t\t\tif (this.physic !== null)                       settings.physic     = this.physic;\n\t\t\tif (this.projection !== Class.PROJECTION.pixel) settings.projection = this.projection;\n\n\t\t\tif (this.tile.width !== 1 || this.tile.height !== 1 || this.tile.depth !== 1) {\n\n\t\t\t\tsettings.tile = {};\n\n\t\t\t\tif (this.tile.width !== 1)  settings.tile.width  = this.tile.width;\n\t\t\t\tif (this.tile.height !== 1) settings.tile.height = this.tile.height;\n\t\t\t\tif (this.tile.depth !== 1)  settings.tile.depth  = this.tile.depth;\n\n\t\t\t}\n\n\n\t\t\tif (this.__layers.length > 0) {\n\t\t\t\t// TODO: Serialize layers and their query paths\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Logic',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        Object.keys(blob).length > 0 ? blob : null\n\t\t\t};\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * STATE API\n\t\t */\n\n\t\tenter: function(data) {\n\n\t\t\tvar layers = this.__layers;\n\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\t\t\t\t_project_layer(layers[l]);\n\t\t\t}\n\n\t\t},\n\n\t\tleave: function(data) {\n\n\t\t\tvar layers = this.__layers;\n\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\t\t\t\t_unproject_layer(layers[l]);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar physic = this.physic;\n\t\t\tif (physic !== null) {\n\t\t\t\tphysic.update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\taddLayer: function(layer) {\n\n\t\t\tlayer = lychee.interfaceof(lychee.game.Layer, layer) ? layer : null;\n\n\n\t\t\tif (layer !== null) {\n\n\t\t\t\tvar index = this.__layers.indexOf(layer);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.__layers.push(layer);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveLayer: function(layer) {\n\n\t\t\tlayer = lychee.interfaceof(lychee.game.Layer, layer) ? layer : null;\n\n\n\t\t\tif (layer !== null) {\n\n\t\t\t\tvar index = this.__layers.indexOf(layer);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.__layers.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetLayers: function(layers) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (layers instanceof Array) {\n\n\t\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\n\t\t\t\t\tvar result = this.addLayer(layers[l]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveLayers: function() {\n\n\t\t\tvar layers = this.__layers;\n\n\t\t\tfor (var l = 0, ll = layers.length; l < ll; l++) {\n\n\t\t\t\tthis.removeLayer(layers[l]);\n\n\t\t\t\tll--;\n\t\t\t\tl--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetPhysic: function(physic) {\n\n\t\t\tphysic = lychee.interfaceof(lychee.game.Physic, physic) ? physic : null;\n\n\n\t\t\tif (physic !== null) {\n\n\t\t\t\tthis.physic = physic;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetProjection: function(projection) {\n\n\t\t\tprojection = lychee.enumof(Class.PROJECTION, projection) ? projection : null;\n\n\n\t\t\tif (projection !== null) {\n\n\t\t\t\tthis.projection = projection;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetTile: function(tile) {\n\n\t\t\tif (tile instanceof Object) {\n\n\t\t\t\tthis.tile.width  = typeof tile.width === 'number'  ? (tile.width  | 0) : this.tile.width;\n\t\t\t\tthis.tile.height = typeof tile.height === 'number' ? (tile.height | 0) : this.tile.height;\n\t\t\t\tthis.tile.depth  = typeof tile.depth === 'number'  ? (tile.depth  | 0) : this.tile.depth;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tprojectPosition: function(position, bound) {\n\n\t\t\tposition = position instanceof Object ? position : null;\n\t\t\tbound    = bound === true;\n\n\n\t\t\tif (position !== null) {\n\n\t\t\t\tvar projection = this.projection;\n\t\t\t\tvar tile       = this.tile;\n\n\t\t\t\tvar x = position.x;\n\t\t\t\tvar y = position.y;\n\t\t\t\tvar z = position.z;\n\n\n\t\t\t\tif (bound === true) {\n\n\t\t\t\t\tx |= 0;\n\t\t\t\t\ty |= 0;\n\t\t\t\t\tz |= 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (projection === Class.PROJECTION.tile) {\n\n\t\t\t\t\tx = x * tile.width;\n\t\t\t\t\ty = y * tile.height;\n\t\t\t\t\tz = z * tile.depth;\n\n\t\t\t\t} else if (projection === Class.PROJECTION.isometry) {\n\n\t\t\t\t\tx = (x - y) * tile.width;\n\t\t\t\t\ty = (x + y) * (tile.height / 2);\n\t\t\t\t\tz = 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tposition.x = x;\n\t\t\t\tposition.y = y;\n\t\t\t\tposition.z = z;\n\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tunprojectPosition: function(position, bound) {\n\n\t\t\tposition = position instanceof Object ? position : null;\n\t\t\tbound    = bound === true;\n\n\n\t\t\tif (position !== null) {\n\n\t\t\t\tvar projection = this.projection;\n\t\t\t\tvar tile       = this.tile;\n\n\t\t\t\tvar x = position.x;\n\t\t\t\tvar y = position.y;\n\t\t\t\tvar z = position.z;\n\n\n\t\t\t\tif (projection === Class.PROJECTION.tile) {\n\n\t\t\t\t\tx = x / tile.width;\n\t\t\t\t\ty = y / tile.height;\n\t\t\t\t\tz = z / tile.depth;\n\n\t\t\t\t} else if (projection === Class.PROJECTION.isometry) {\n\n\t\t\t\t\tx = (y / tile.height) + (x / (2 * tile.width));\n\t\t\t\t\ty = (y / tile.height) - (x / (2 * tile.width));\n\t\t\t\t\tz = 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (bound === true) {\n\n\t\t\t\t\tx |= 0;\n\t\t\t\t\ty |= 0;\n\t\t\t\t\tz |= 0;\n\n\t\t\t\t}\n\n\n\t\t\t\tposition.x = x;\n\t\t\t\tposition.y = y;\n\t\t\t\tposition.z = z;\n\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.ui.Layer":{"constructor":"lychee.Definition","arguments":["lychee.ui.Layer"],"blob":{"includes":["lychee.ui.Entity"],"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _validate_entity = function(entity) {\n\n\t\tif (entity instanceof Object) {\n\n\t\t\tif (typeof entity.update === 'function' && typeof entity.render === 'function' && typeof entity.shape === 'number') {\n\n\t\t\t\tif (typeof entity.isAtPosition === 'function') {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn false;\n\n\t};\n\n\tvar _process_touch = function(id, position, delta) {\n\n\t\tvar triggered = null;\n\t\tvar args      = [ id, {\n\t\t\tx: position.x - this.offset.x,\n\t\t\ty: position.y - this.offset.y\n\t\t}, delta ];\n\n\n\t\tvar entity = this.getEntity(null, args[1]);\n\t\tif (entity !== null) {\n\n\t\t\tif (typeof entity.trigger === 'function') {\n\n\t\t\t\targs[1].x -= entity.position.x;\n\t\t\t\targs[1].y -= entity.position.y;\n\n\t\t\t\tvar result = entity.trigger('touch', args);\n\t\t\t\tif (result === true) {\n\t\t\t\t\ttriggered = entity;\n\t\t\t\t} else if (result !== false) {\n\t\t\t\t\ttriggered = result;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn triggered;\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.entities = [];\n\t\tthis.offset   = { x: 0, y: 0 };\n\t\tthis.visible  = true;\n\n\t\tthis.__map     = {};\n\t\tthis.__reshape = true;\n\n\n\t\tthis.setEntities(settings.entities);\n\t\tthis.setOffset(settings.offset);\n\t\tthis.setReshape(settings.reshape);\n\t\tthis.setVisible(settings.visible);\n\n\t\tdelete settings.entities;\n\t\tdelete settings.offset;\n\t\tdelete settings.reshape;\n\t\tdelete settings.visible;\n\n\n\t\tsettings.shape = lychee.ui.Entity.SHAPE.rectangle;\n\n\n\t\tlychee.ui.Entity.call(this, settings);\n\n\t\tsettings = null;\n\n\n\n\t\t/*\n\t\t * INITIALIZATION\n\t\t */\n\n\t\tthis.bind('touch', _process_touch, this);\n\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\tdeserialize: function(blob) {\n\n\t\t\tvar entities = [];\n\t\t\tfor (var be = 0, bel = blob.entities.length; be < bel; be++) {\n\t\t\t\tentities.push(lychee.deserialize(blob.entities[be]));\n\t\t\t}\n\n\t\t\tvar map = {};\n\t\t\tfor (var bid in blob.map) {\n\n\t\t\t\tvar index = blob.map[bid];\n\t\t\t\tif (typeof index === 'number') {\n\t\t\t\t\tmap[bid] = index;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tvar id = null;\n\t\t\t\tfor (var mid in map) {\n\n\t\t\t\t\tif (map[mid] === e) {\n\t\t\t\t\t\tid = mid;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (id !== null) {\n\t\t\t\t\tthis.setEntity(id, entities[e]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.addEntity(entities[e]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function() {\n\n\t\t\tvar data = lychee.ui.Entity.prototype.serialize.call(this);\n\t\t\tdata['constructor'] = 'lychee.ui.Layer';\n\n\t\t\tvar settings = data['arguments'][0];\n\t\t\tvar blob     = data['blob'] = (data['blob'] || {});\n\n\n\t\t\tif (this.offset.x !== 0 || this.offset.y !== 0) {\n\n\t\t\t\tsettings.offset = {};\n\n\t\t\t\tif (this.offset.x !== 0) settings.offset.x = this.offset.x;\n\t\t\t\tif (this.offset.y !== 0) settings.offset.y = this.offset.y;\n\n\t\t\t}\n\n\t\t\tif (this.__reshape !== true) settings.reshape = this.__reshape;\n\t\t\tif (this.visible !== true)   settings.visible = this.visible;\n\n\n\t\t\tvar entities = [];\n\n\t\t\tif (this.entities.length > 0) {\n\n\t\t\t\tblob.entities = [];\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\n\t\t\t\t\tblob.entities.push(lychee.serialize(entity));\n\t\t\t\t\tentities.push(entity);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (Object.keys(this.__map).length > 0) {\n\n\t\t\t\tblob.map = {};\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tvar index = entities.indexOf(this.__map[id]);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tblob.map[id] = index;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tdata.blob = Object.keys(data.blob).length > 0 ? data.blob : null;\n\n\n\t\t\treturn data;\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tlychee.ui.Entity.prototype.update.call(this, clock, delta);\n\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\t\t\t\tentities[e].update(clock, delta);\n\t\t\t}\n\n\t\t},\n\n\t\trender: function(renderer, offsetX, offsetY) {\n\n\t\t\tif (this.visible === false) return;\n\n\n\t\t\tvar position = this.position;\n\t\t\tvar offset   = this.offset;\n\n\n\t\t\tvar ox = position.x + offsetX + offset.x;\n\t\t\tvar oy = position.y + offsetY + offset.y;\n\n\n\t\t\tvar entities = this.entities;\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tentities[e].render(\n\t\t\t\t\trenderer,\n\t\t\t\t\tox,\n\t\t\t\t\toy\n\t\t\t\t);\n\n\t\t\t}\n\n\n\t\t\tif (lychee.debug === true) {\n\n\t\t\t\tox = position.x + offsetX;\n\t\t\t\toy = position.y + offsetY;\n\n\n\t\t\t\tvar hwidth   = this.width  / 2;\n\t\t\t\tvar hheight  = this.height / 2;\n\n\n\t\t\t\trenderer.drawBox(\n\t\t\t\t\tox - hwidth,\n\t\t\t\t\toy - hheight,\n\t\t\t\t\tox + hwidth,\n\t\t\t\t\toy + hheight,\n\t\t\t\t\t'#ff00ff',\n\t\t\t\t\tfalse,\n\t\t\t\t\t1\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\treshape: function() {\n\n\t\t\tif (this.__reshape === true) {\n\n\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\tvar hheight = this.height / 2;\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\tif (typeof entity.reshape === 'function') {\n\t\t\t\t\t\tentity.reshape();\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar boundx = Math.abs(entity.position.x + this.offset.x);\n\t\t\t\t\tvar boundy = Math.abs(entity.position.y + this.offset.y);\n\n\t\t\t\t\tif (entity.shape === lychee.ui.Entity.SHAPE.circle) {\n\t\t\t\t\t\tboundx += entity.radius;\n\t\t\t\t\t\tboundy += entity.radius;\n\t\t\t\t\t} else if (entity.shape === lychee.ui.Entity.SHAPE.rectangle) {\n\t\t\t\t\t\tboundx += entity.width  / 2;\n\t\t\t\t\t\tboundy += entity.height / 2;\n\t\t\t\t\t}\n\n\t\t\t\t\thwidth  = Math.max(hwidth,  boundx);\n\t\t\t\t\thheight = Math.max(hheight, boundy);\n\n\t\t\t\t}\n\n\t\t\t\tthis.width  = hwidth  * 2;\n\t\t\t\tthis.height = hheight * 2;\n\n\t\t\t}\n\n\t\t},\n\n\t\taddEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar index = this.entities.indexOf(entity);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.entities.push(entity);\n\t\t\t\t\tthis.reshape();\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntity: function(id, entity) {\n\n\t\t\tid     = typeof id === 'string'            ? id     : null;\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (id !== null && entity !== null && this.__map[id] === undefined) {\n\n\t\t\t\tthis.__map[id] = entity;\n\n\t\t\t\tvar result = this.addEntity(entity);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetEntity: function(id, position) {\n\n\t\t\tid        = typeof id === 'string'    ? id       : null;\n\t\t\tposition = position instanceof Object ? position : null;\n\n\n\t\t\tvar found = null;\n\n\n\t\t\tif (id !== null) {\n\n\t\t\t\tif (this.__map[id] !== undefined) {\n\t\t\t\t\tfound = this.__map[id];\n\t\t\t\t}\n\n\t\t\t} else if (position !== null) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tfor (var e = this.entities.length - 1; e >= 0; e--) {\n\n\t\t\t\t\t\tvar entity = this.entities[e];\n\t\t\t\t\t\tif (entity.visible === false) continue;\n\n\t\t\t\t\t\tif (entity.isAtPosition(position) === true) {\n\t\t\t\t\t\t\tfound = entity;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn found;\n\n\t\t},\n\n\t\tremoveEntity: function(entity) {\n\n\t\t\tentity = _validate_entity(entity) === true ? entity : null;\n\n\n\t\t\tif (entity !== null) {\n\n\t\t\t\tvar found = false;\n\n\t\t\t\tfor (var e = 0, el = this.entities.length; e < el; e++) {\n\n\t\t\t\t\tif (this.entities[e] === entity) {\n\t\t\t\t\t\tthis.entities.splice(e, 1);\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tel--;\n\t\t\t\t\t\te--;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfor (var id in this.__map) {\n\n\t\t\t\t\tif (this.__map[id] === entity) {\n\t\t\t\t\t\tdelete this.__map[id];\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (found === true) {\n\t\t\t\t\tthis.reshape();\n\t\t\t\t}\n\n\n\t\t\t\treturn found;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetEntities: function(entities) {\n\n\t\t\tvar all = true;\n\n\t\t\tif (entities instanceof Array) {\n\n\t\t\t\tthis.entities = [];\n\n\t\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\t\tvar result = this.addEntity(entities[e]);\n\t\t\t\t\tif (result === false) {\n\t\t\t\t\t\tall = false;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn all;\n\n\t\t},\n\n\t\tremoveEntities: function() {\n\n\t\t\tvar entities = this.entities;\n\n\t\t\tfor (var e = 0, el = entities.length; e < el; e++) {\n\n\t\t\t\tthis.removeEntity(entities[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetOffset: function(offset) {\n\n\t\t\tif (offset instanceof Object) {\n\n\t\t\t\tthis.offset.x = typeof offset.x === 'number' ? offset.x : this.offset.x;\n\t\t\t\tthis.offset.y = typeof offset.y === 'number' ? offset.y : this.offset.y;\n\n\t\t\t\tthis.reshape();\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetReshape: function(reshape) {\n\n\t\t\tif (reshape === true || reshape === false) {\n\n\t\t\t\tthis.__reshape = reshape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVisible: function(visible) {\n\n\t\t\tif (visible === true || visible === false) {\n\n\t\t\t\tthis.visible = visible;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.Entity":{"constructor":"lychee.Definition","arguments":["lychee.game.Entity"],"blob":{"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _sphere_sphere = function(a, b) {\n\n\t\tvar dx  = Math.sqrt(Math.pow(b.position.x - a.position.x, 2));\n\t\tvar dy  = Math.sqrt(Math.pow(b.position.y - a.position.y, 2));\n\t\tvar dz  = Math.sqrt(Math.pow(b.position.z - a.position.z, 2));\n\n\t\tvar rxy = 0;\n\t\tvar rxz = 0;\n\n\t\tif (a.shape === Class.SHAPE.sphere) {\n\t\t\trxy += a.radius;\n\t\t\trxz += a.radius;\n\t\t}\n\n\t\tif (b.shape === Class.SHAPE.sphere) {\n\t\t\trxy += b.radius;\n\t\t\trxz += b.radius;\n\t\t}\n\n\t\treturn ((dx + dy) <= rxy && (dx + dz) <= rxz);\n\n\t};\n\n\tvar _sphere_cuboid = function(a, b) {\n\n\t\tvar r  = a.radius;\n\t\tvar hw = b.width  / 2;\n\t\tvar hh = b.height / 2;\n\t\tvar hd = b.depth  / 2;\n\n\t\tvar ax = a.position.x;\n\t\tvar ay = a.position.y;\n\t\tvar az = a.position.z;\n\n\t\tvar bx = b.position.x;\n\t\tvar by = b.position.y;\n\t\tvar bz = b.position.z;\n\n\t\tvar colx = (ax + r >= bx - hw) && (ax - r <= bx + hw);\n\t\tvar coly = (ay + r >= by - hh) && (ay - r <= by + hh);\n\n\t\tif (a.shape === Class.SHAPE.circle) {\n\t\t\tr = 0;\n\t\t}\n\n\t\tvar colz = (az + r >= bz - hd) && (az - r <= bz + hd);\n\n\t\treturn (colx && coly && colz);\n\n\t};\n\n\tvar _cuboid_cuboid = function(a, b) {\n\n\t\tvar dx = Math.abs(b.position.x - a.position.x);\n\t\tvar dy = Math.abs(b.position.y - a.position.y);\n\t\tvar dz = Math.abs(b.position.z - a.position.z);\n\n\t\tvar hw = (a.width  + b.width)  / 2;\n\t\tvar hh = (a.height + b.height) / 2;\n\t\tvar hd = (a.depth  + b.depth)  / 2;\n\n\t\treturn (dx <= hw && dy <= hh && dz <= hd);\n\n\t};\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar _default_state  = 'default';\n\tvar _default_states = { 'default': null };\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.width  = typeof settings.width  === 'number' ? settings.width  : 0;\n\t\tthis.height = typeof settings.height === 'number' ? settings.height : 0;\n\t\tthis.depth  = typeof settings.depth  === 'number' ? settings.depth  : 0;\n\t\tthis.radius = typeof settings.radius === 'number' ? settings.radius : 0;\n\n\t\tthis.alpha     = 1;\n\t\tthis.collision = Class.COLLISION.none;\n\t\tthis.effects   = [];\n\t\tthis.shape     = Class.SHAPE.rectangle;\n\t\tthis.state     = _default_state;\n\t\tthis.position  = { x: 0, y: 0, z: 0 };\n\t\tthis.velocity  = { x: 0, y: 0, z: 0 };\n\n\t\tthis.__states  = _default_states;\n\n\n\t\tif (settings.states instanceof Object) {\n\n\t\t\tthis.__states = { 'default': null };\n\n\t\t\tfor (var id in settings.states) {\n\n\t\t\t\tif (settings.states.hasOwnProperty(id)) {\n\t\t\t\t\tthis.__states[id] = settings.states[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.setAlpha(settings.alpha);\n\t\tthis.setCollision(settings.collision);\n\t\tthis.setShape(settings.shape);\n\t\tthis.setState(settings.state);\n\t\tthis.setPosition(settings.position);\n\t\tthis.setVelocity(settings.velocity);\n\n\n\t\tsettings = null;\n\n\t};\n\n\n\tClass.COLLISION = {\n\t\tnone: 0,\n\t\tA:    1,\n\t\tB:    2,\n\t\tC:    3,\n\t\tD:    4\n\t};\n\n\n\t// Same ENUM values as lychee.ui.Entity\n\tClass.SHAPE = {\n\t\tcircle:    0,\n\t\trectangle: 1,\n\t\tsphere:    2,\n\t\tcuboid:    3\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) {},\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.width  !== 0) settings.width  = this.width;\n\t\t\tif (this.height !== 0) settings.height = this.height;\n\t\t\tif (this.depth  !== 0) settings.depth  = this.depth;\n\t\t\tif (this.radius !== 0) settings.radius = this.radius;\n\n\t\t\tif (this.alpha !== 1)                         settings.alpha     = this.alpha;\n\t\t\tif (this.collision !== Class.COLLISION.none)  settings.collision = this.collision;\n\t\t\tif (this.shape !== Class.SHAPE.rectangle)     settings.shape     = this.shape;\n\t\t\tif (this.state !== _default_state)            settings.state     = this.state;\n\t\t\tif (this.__states !== _default_states)        settings.states    = this.__states;\n\n\n\t\t\tif (this.position.x !== 0 || this.position.y !== 0 || this.position.z !== 0) {\n\n\t\t\t\tsettings.position = {};\n\n\t\t\t\tif (this.position.x !== 0) settings.position.x = this.position.x;\n\t\t\t\tif (this.position.y !== 0) settings.position.y = this.position.y;\n\t\t\t\tif (this.position.z !== 0) settings.position.z = this.position.z;\n\n\t\t\t}\n\n\n\t\t\tif (this.velocity.x !== 0 || this.velocity.y !== 0 || this.velocity.z !== 0) {\n\n\t\t\t\tsettings.velocity = {};\n\n\t\t\t\tif (this.velocity.x !== 0) settings.velocity.x = this.velocity.x;\n\t\t\t\tif (this.velocity.y !== 0) settings.velocity.y = this.velocity.y;\n\t\t\t\tif (this.velocity.z !== 0) settings.velocity.z = this.velocity.z;\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.game.Entity',\n\t\t\t\t'arguments':   [ settings ]\n\t\t\t};\n\n\t\t},\n\n\t\t// HINT: Renderer skips if no render() method exists\n\t\trender: function(renderer, offsetX, offsetY) {\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var e = 0, el = this.effects.length; e < el; e++) {\n\t\t\t\tthis.effects[e].render(renderer, offsetX, offsetY);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar velocity = this.velocity;\n\n\t\t\tif (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n\n\t\t\t\tvar x = this.position.x;\n\t\t\t\tvar y = this.position.y;\n\t\t\t\tvar z = this.position.z;\n\n\n\t\t\t\tvar vt = delta / 1000;\n\n\t\t\t\tif (velocity.x !== 0) {\n\t\t\t\t\tx += velocity.x * vt;\n\t\t\t\t}\n\n\t\t\t\tif (velocity.y !== 0) {\n\t\t\t\t\ty += velocity.y * vt;\n\t\t\t\t}\n\n\t\t\t\tif (velocity.z !== 0) {\n\t\t\t\t\tz += velocity.z * vt;\n\t\t\t\t}\n\n\n\t\t\t\tthis.position.x = x;\n\t\t\t\tthis.position.y = y;\n\t\t\t\tthis.position.z = z;\n\n\t\t\t}\n\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var e = 0, el = this.effects.length; e < el; e++) {\n\n\t\t\t\tvar effect = this.effects[e];\n\t\t\t\tif (effect.update(this, clock, delta) === false) {\n\t\t\t\t\tthis.removeEffect(effect);\n\t\t\t\t\tel--;\n\t\t\t\t\te--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tisAtPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tvar ax = position.x;\n\t\t\t\t\tvar ay = position.y;\n\t\t\t\t\tvar bx = this.position.x;\n\t\t\t\t\tvar by = this.position.y;\n\n\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tif (shape === Class.SHAPE.circle) {\n\n\t\t\t\t\t\tvar dist = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\t\t\t\t\t\tif (dist < this.radius) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (shape === Class.SHAPE.rectangle) {\n\n\t\t\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\t\t\tvar hheight = this.height / 2;\n\t\t\t\t\t\tvar colX    = (ax >= bx - hwidth)  && (ax <= bx + hwidth);\n\t\t\t\t\t\tvar colY    = (ay >= by - hheight) && (ay <= by + hheight);\n\n\n\t\t\t\t\t\treturn colX && colY;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tcollidesWith: function(entity) {\n\n\t\t\tvar none = Class.COLLISION.none;\n\t\t\tif (this.collision !== entity.collision || this.collision === none || entity.collision === none) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\n\t\t\tvar circle    = Class.SHAPE.circle;\n\t\t\tvar sphere    = Class.SHAPE.sphere;\n\t\t\tvar rectangle = Class.SHAPE.rectangle;\n\t\t\tvar cuboid    = Class.SHAPE.cuboid;\n\n\t\t\tvar shapeA    = this.shape;\n\t\t\tvar shapeB    = entity.shape;\n\n\t\t\tvar issphereA = shapeA === circle    || shapeA === sphere;\n\t\t\tvar issphereB = shapeB === circle    || shapeB === sphere;\n\t\t\tvar iscuboidA = shapeA === rectangle || shapeA === cuboid;\n\t\t\tvar iscuboidB = shapeB === rectangle || shapeB === cuboid;\n\n\t\t\tif (issphereA && issphereB) {\n\t\t\t\treturn _sphere_sphere(this, entity);\n\t\t\t} else if (iscuboidA && iscuboidB) {\n\t\t\t\treturn _cuboid_cuboid(this, entity);\n\t\t\t} else if (issphereA && iscuboidB) {\n\t\t\t\treturn _sphere_cuboid(this, entity);\n\t\t\t} else if (iscuboidA && issphereB) {\n\t\t\t\treturn _sphere_cuboid(entity, this);\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\n\t\t\talpha = (typeof alpha === 'number' && alpha >= 0 && alpha <= 1) ? alpha : null;\n\n\n\t\t\tif (alpha !== null) {\n\n\t\t\t\tthis.alpha = alpha;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetCollision: function(collision) {\n\n\t\t\tif (lychee.enumof(Class.COLLISION, collision)) {\n\n\t\t\t\tthis.collision = collision;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\taddEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.effects.push(effect);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.effects.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffects: function() {\n\n\t\t\tvar effects = this.effects;\n\n\t\t\tfor (var e = 0, el = effects.length; e < el; e++) {\n\n\t\t\t\teffects[e].update(this, Infinity, 0);\n\t\t\t\tthis.removeEffect(effects[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetPosition: function(position) {\n\n\t\t\tposition = position instanceof Object ? position : null;\n\n\n\t\t\tif (position !== null) {\n\n\t\t\t\tthis.position.x = typeof position.x === 'number' ? position.x : this.position.x;\n\t\t\t\tthis.position.y = typeof position.y === 'number' ? position.y : this.position.y;\n\t\t\t\tthis.position.z = typeof position.z === 'number' ? position.z : this.position.z;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetShape: function(shape) {\n\n\t\t\tif (lychee.enumof(Class.SHAPE, shape)) {\n\n\t\t\t\tthis.shape = shape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetStateMap: function() {\n\t\t\treturn this.__states[this.state];\n\t\t},\n\n\t\tsetState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__states[id] !== undefined) {\n\n\t\t\t\tthis.state = id;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVelocity: function(velocity) {\n\n\t\t\tvelocity = velocity instanceof Object ? velocity : null;\n\n\n\t\t\tif (velocity !== null) {\n\n\t\t\t\tthis.velocity.x = typeof velocity.x === 'number' ? velocity.x : this.velocity.x;\n\t\t\t\tthis.velocity.y = typeof velocity.y === 'number' ? velocity.y : this.velocity.y;\n\t\t\t\tthis.velocity.z = typeof velocity.z === 'number' ? velocity.z : this.velocity.z;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.game.Physic":{"constructor":"lychee.Definition","arguments":["lychee.game.Physic"],"blob":{"exports":"function (lychee, global, attachments) {\n\n\tvar Class = function(data) {\n\t};\n\n\n\tClass.prototype = {\n\t};\n\n\n\treturn Class;\n\n}"}},"lychee.ui.Entity":{"constructor":"lychee.Definition","arguments":["lychee.ui.Entity"],"blob":{"includes":["lychee.event.Emitter"],"exports":"function (lychee, global) {\n\n\t/*\n\t * HELPERS\n\t */\n\n\tvar _default_state  = 'default';\n\tvar _default_states = { 'default': null, 'active': null };\n\n\n\n\t/*\n\t * IMPLEMENTATION\n\t */\n\n\tvar Class = function(data) {\n\n\t\tvar settings = lychee.extend({}, data);\n\n\n\t\tthis.width  = typeof settings.width  === 'number' ? settings.width  : 0;\n\t\tthis.height = typeof settings.height === 'number' ? settings.height : 0;\n\t\tthis.depth  = 0;\n\t\tthis.radius = typeof settings.radius === 'number' ? settings.radius : 0;\n\n\t\tthis.alpha     = 1;\n\t\tthis.collision = 1; // Used for event flow, NOT modifiable\n\t\tthis.effects   = [];\n\t\tthis.shape     = Class.SHAPE.rectangle;\n\t\tthis.state     = _default_state;\n\t\tthis.position  = { x: 0, y: 0 };\n\t\tthis.visible   = true;\n\n\t\tthis.__states  = _default_states;\n\n\n\t\tif (settings.states instanceof Object) {\n\n\t\t\tthis.__states = { 'default': null, 'active': null };\n\n\t\t\tfor (var id in settings.states) {\n\n\t\t\t\tif (settings.states.hasOwnProperty(id)) {\n\t\t\t\t\tthis.__states[id] = settings.states[id];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tthis.setAlpha(settings.alpha);\n\t\tthis.setShape(settings.shape);\n\t\tthis.setState(settings.state);\n\t\tthis.setPosition(settings.position);\n\t\tthis.setVisible(settings.visible);\n\n\n\t\tlychee.event.Emitter.call(this);\n\n\t\tsettings = null;\n\n\t};\n\n\n\t// Same ENUM values as lychee.game.Entity\n\tClass.SHAPE = {\n\t\tcircle:    0,\n\t\trectangle: 2\n\t};\n\n\n\tClass.prototype = {\n\n\t\t/*\n\t\t * ENTITY API\n\t\t */\n\n\t\t// deserialize: function(blob) { },\n\n\t\tserialize: function() {\n\n\t\t\tvar settings = {};\n\n\n\t\t\tif (this.width  !== 0) settings.width  = this.width;\n\t\t\tif (this.height !== 0) settings.height = this.height;\n\t\t\tif (this.radius !== 0) settings.radius = this.radius;\n\n\t\t\tif (this.alpha !== 1)                     settings.alpha   = this.alpha;\n\t\t\tif (this.shape !== Class.SHAPE.rectangle) settings.shape   = this.shape;\n\t\t\tif (this.state !== _default_state)        settings.state   = this.state;\n\t\t\tif (this.__states !== _default_states)    settings.states  = this.__states;\n\t\t\tif (this.visible !== true)                settings.visible = this.visible;\n\n\n\t\t\tif (this.position.x !== 0 || this.position.y !== 0) {\n\n\t\t\t\tsettings.position = {};\n\n\t\t\t\tif (this.position.x !== 0) settings.position.x = this.position.x;\n\t\t\t\tif (this.position.y !== 0) settings.position.y = this.position.y;\n\n\t\t\t}\n\n\n\t\t\treturn {\n\t\t\t\t'constructor': 'lychee.ui.Entity',\n\t\t\t\t'arguments':   [ settings ],\n\t\t\t\t'blob':        null\n\t\t\t};\n\n\t\t},\n\n\t\t// HINT: Renderer skips if no render() method exists\n\t\t// render: function(renderer, offsetX, offsetY) {},\n\n\t\tupdate: function(clock, delta) {\n\n\t\t\tvar effects = this.effects;\n\t\t\tfor (var e = 0, el = this.effects.length; e < el; e++) {\n\n\t\t\t\tvar effect = this.effects[e];\n\t\t\t\tif (effect.update(this, clock, delta) === false) {\n\t\t\t\t\tthis.removeEffect(effect);\n\t\t\t\t\tel--;\n\t\t\t\t\te--;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\n\n\t\t/*\n\t\t * CUSTOM API\n\t\t */\n\n\t\tisAtPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tif (typeof position.x === 'number' && typeof position.y === 'number') {\n\n\t\t\t\t\tvar ax = position.x;\n\t\t\t\t\tvar ay = position.y;\n\t\t\t\t\tvar bx = this.position.x;\n\t\t\t\t\tvar by = this.position.y;\n\n\n\t\t\t\t\tvar shape = this.shape;\n\t\t\t\t\tif (shape === Class.SHAPE.circle) {\n\n\t\t\t\t\t\tvar dist = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\t\t\t\t\t\tif (dist < this.radius) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (shape === Class.SHAPE.rectangle) {\n\n\t\t\t\t\t\tvar hwidth  = this.width  / 2;\n\t\t\t\t\t\tvar hheight = this.height / 2;\n\t\t\t\t\t\tvar colX    = (ax >= bx - hwidth)  && (ax <= bx + hwidth);\n\t\t\t\t\t\tvar colY    = (ay >= by - hheight) && (ay <= by + hheight);\n\n\n\t\t\t\t\t\treturn colX && colY;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\n\t\t\talpha = (typeof alpha === 'number' && alpha >= 0 && alpha <= 1) ? alpha : null;\n\n\n\t\t\tif (alpha !== null) {\n\n\t\t\t\tthis.alpha = alpha;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\taddEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index === -1) {\n\n\t\t\t\t\tthis.effects.push(effect);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffect: function(effect) {\n\n\t\t\teffect = effect instanceof Object && typeof effect.update === 'function' ? effect : null;\n\n\n\t\t\tif (effect !== null) {\n\n\t\t\t\tvar index = this.effects.indexOf(effect);\n\t\t\t\tif (index !== -1) {\n\n\t\t\t\t\tthis.effects.splice(index, 1);\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tremoveEffects: function() {\n\n\t\t\tvar effects = this.effects;\n\n\t\t\tfor (var e = 0, el = effects.length; e < el; e++) {\n\n\t\t\t\teffects[e].update(this, Infinity, 0);\n\t\t\t\tthis.removeEffect(effects[e]);\n\n\t\t\t\tel--;\n\t\t\t\te--;\n\n\t\t\t}\n\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tsetPosition: function(position) {\n\n\t\t\tif (position instanceof Object) {\n\n\t\t\t\tthis.position.x = typeof position.x === 'number' ? position.x : this.position.x;\n\t\t\t\tthis.position.y = typeof position.y === 'number' ? position.y : this.position.y;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetShape: function(shape) {\n\n\t\t\tif (lychee.enumof(Class.SHAPE, shape)) {\n\n\t\t\t\tthis.shape = shape;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tgetStateMap: function() {\n\t\t\treturn this.__states[this.state];\n\t\t},\n\n\t\tsetState: function(id) {\n\n\t\t\tid = typeof id === 'string' ? id : null;\n\n\n\t\t\tif (id !== null && this.__states[id] !== undefined) {\n\n\t\t\t\tthis.state = id;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t},\n\n\t\tsetVisible: function(visible) {\n\n\t\t\tif (visible === true || visible === false) {\n\n\t\t\t\tthis.visible = visible;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n\n\treturn Class;\n\n}"}}},"type":"build","build":"lychee.game.Main"}});

	if (environment !== null) {
		environment.init();
	}

	lychee.ENVIRONMENTS['lychee/nodejs/main'] = environment;

})(lychee, typeof global !== 'undefined' ? global : this);

